
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transactional Consistency In Frameworks</title>
    <link rel="stylesheet" href="../../styles.css">
    <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
</head>
<body>
    <header>
        <h1>Transactional Consistency In Frameworks</h1>
    </header>
    <main>
        <article>
            <h1>How to Propegate Transactions Across Repositories</h1>
            <p class="date">May 7, 2025</p>
            <p>
                When handling requests within a backend application, multiple database queries will typically need to occur in order to 
                acomplish needed business functionality. Dealing with multiple queries to the database often means that a transaction will
                need to be used in order to ensure data consistency. Assuming a basic three layer architecture, an application will typically have
                some form of repositories or DAOs living in the infrastructure layer used to interface with databases. 
                Often times business functionality spans multiple repositories, meaning that a singular database connection which starts a
                transaction must be shared between multiple separate repositories. There are multiple methods to achieve this, but depending on how 
                the underlying data is structured, it might not be necessary at all. 
            </p>
            <h2>Avoid with DDD</h2>
            <p>
                One of my other articles goes in depth about DDD and its usage of the repository pattern, although with a smart domain model
                transactions which span repositories should be unnecessary. Repositories should fetch an aggregate root, which contains enough
                information to make decisions about business functionality which must be transactionally consistent. With this approach, 
                if transactions must span mutliple repositories, the domain model must be reconsidered.
            </p>
            <h2>Naive passing of database connection from application layer</h2>
            <p>
                One very simple approach to managing consistency across repositories is to make each repository method accept an optional 
                database connection. If one is provided, it will use that for the query to the database, otherwise it will grab a connection
                from the pool that it has access to and make an isolated request. The following is some basic golang code that I wrote for a 
                distributed system backend application for a website that mimics the functionality of letterboxdd, but for music

  <pre class="prettyprint lang-go">func(p *PostsDAO) LikePost(executor db.QueryExecutor, 
                           spotifyID string, 
                           posterSpotifyID string, 
                           songID string) error {
    query := 
        `INSERT INTO post_votes 
            (voterspotifyid, posterspotifyid, postsongid, createdat, updatedat, liked) 
        VALUES 
            ($1, $2, $3, $4, $5, $6) 
        ON CONFLICT 
            (voterspotifyid, posterspotifyid, postsongid) 
        DO UPDATE SET 
            updatedat=$5, liked=$6`

    res, err := executor.Exec(query,
        spotifyID,
        posterSpotifyID,
        songID,
        time.Now().UTC(),
        time.Now().UTC(),
        true)

    if err != nil {
        return customerrors.WrapBasicError(err)
    }

    rows, err := res.RowsAffected()

    if err != nil {
        return customerrors.WrapBasicError(err)
    }

    if rows < 1 {
        return customerrors.WrapBasicError(sql.ErrNoRows)
    }

    return nil

}
</pre>
                
                As you can see, the first argument to the function is a query exectutor, and interface that I created which wraps
                a database connection so that you can swap out the underlying database connection without any issues.
                This might seem ok, although it creates unnecssary complexity within the application layer, meaing that the application layer 
                must manage the database connection which leads into a leaky abstraction between the application layer and infrastructure layer

            </p>
            <h2>Context/Async/Thread local storage and interceptors (required request scoped repositories for singleton apps)</h2>
                Moving to more sophisticated solutions, we can take advantage of something called thread local storage. Also known
                as Async and Context local storage, thread local storage helps to store information isolated to a single execution thread.
                This makes it possible to initilize a transaction and expose the database connection via thread local storage, and then 
                have each individual repository check first if there is an avaialble connection in the thread local storage, and if not
                simply grab a connection in the pool and use that one. In order to create the database connection in the first place, 
                we need to know whether a method needs to use a transaction or not. This can be done with somethign called interceptors 
                in nestjs, but other frameworks have similar patterns. The idea is to decorate a method, and have code run before the 
                handler for each business action. In our case, if we decorate our method with a transaction interceptor, we want to create
                a transaction and populate the context local storage with that database connection, so that we can access it via our repositories

                This can be seen like so 



  <pre class="prettyprint lang-typescript">export class TransactionInterceptor implements NestInterceptor {
  constructor(
    private dataSource: DataSource,
    private cls: ClsService,
  ) {}

  async intercept(
    context: ExecutionContext,
    next: CallHandler,
  ): Promise<Observable<any>> {
    const queryRunner = this.dataSource.createQueryRunner();
    queryRunner.connect();
    queryRunner.startTransaction();
    const manager = queryRunner.manager;
    this.cls.set('connection', manager);
    return next.handle().pipe(
      concatMap(async (data) => {
        await queryRunner.commitTransaction();
        return data;
      }),
      catchError(async (error) => {
        await queryRunner.rollbackTransaction();
        throw error;
      }),
      finalize(async () => {
        await queryRunner.release();
      }),
    );
  }
}
  </pre>


  DAO accessing the cls in order to check if a database connection exists before grabbing one from the pool

<pre class="prettyprint lang-typescript">@Injectable({ scope: Scope.REQUEST })
export class InventoryDAO {
  private queryRunner: EntityManager;
  constructor(cls: ClsService, dataSource: DataSource) {
  constructor(
    private cls: ClsService,
    private dataSource: DataSource,
  ) {
    this.queryRunner = cls.get('connection') ?? dataSource.manager;
  }

  // return the id of the item if in stock
  async getStock(itemName: string): Promise<number> {
    this.queryRunner = this.cls.get('connection') ?? this.dataSource.manager;
    const res = await this.queryRunner.query<Inventory>(
      `SELECT count(*) FROM inventory WHERE "itemName" = $1`,
      [itemName],
    );
    return res[0].count;
  }
  </pre>

  usage of the decorator

<pre class="prettyprint lang-typescript">@Controller('orders')
@UseInterceptors(TransactionInterceptor)
@UseInterceptors(TransactionInterceptor)
export class OrdersController {
  constructor(private ordersService: OrdersService) {}

  @Post()
  async placeOrder() {
    return await this.ordersService.placeOrder('test', 'blah', 1);
    return await this.ordersService.placeOrder('test', 'jack', 1000);
  }
}
  </pre>
  This is good, but I wanted a more foundational understanding of how this could be achieved, 
  and I happened to stumble upon the unit of work pattern


            <h2>Unit of work pattern</h2>


            The unit of work pattern is a way to abstract all functionality that occurs within the database across the application, 
            to make changes across repositories and then commit them all at once. At its core, the unit of work pattern
            manages request scoped instance of repositories. The unit of work class starts a database transaction and provides the 
            request scoped repositories with an instance of the database connection using the transaction. There are methods on the 
            unit of work class to fetch these repositories, and then there is also a method to commit or rollback the overarching transaction. 
            This way, the unit of work is injected into services, can be mocked, encapsulates the database transaction information to reduce
            leaky abstractions, and allows for multiple repositories to participate in the same transaction. It can also be implemented 
            a bit more "raw", returning the connection to the user and having them manually begin, commit, and rollback connections. This does
            leak the abstraction, but it was the implementation that I went with beacuse I was inspired by <a href='https://orkhan.gitbook.io/typeorm/docs/transactions#using-queryrunner-to-create-and-control-state-of-single-database-connection'>typeorm.</a>
            We can see here that I've created my unit of work class, called transaction manager


<pre class="prettyprint lang-typescript">
import { Injectable } from '@nestjs/common';
import { Pool, PoolClient } from 'pg';
import { DAO } from '../types';

Injectable();
export class TransactionManager {
  constructor(private pool: Pool) {}

  /* the end user must call repository.close() when done with use 
  on transaction, that way the connection is closed! */
  async getDAOsForTransaction(
    ...constructors: DAO<any>[]
  ): Promise<[any[], PoolClient]> {
    const connection = await this.pool.connect();
    return [
      constructors.map((constructor) => new constructor(connection)),
      connection,
    ];
  }
}
            </pre>

            it, given the names of repositories, will instantiate the list of repositories with the newly grabbed connection from the pool. 
            it then returns the repositories and the connection to the user, to use. It can be used like so

<pre class="prettyprint lang-typescript">@Injectable()
export class OrdersService {
  constructor(
    private paymentService: PaymentService,
    private inventoryService: InventoryService,
    private invoiceService: InvoiceService,
    private transactionManager: TransactionManager,
  ) {}
  async placeOrder(itemName: string, user: string) {
    const price = await this.inventoryService.getPrice(itemName);
    await this.paymentService.checkAndChargePayment(user, price);
    await this.inventoryService.checkAndReduceStock(itemName);
    await this.invoiceService.provideInvoice(user, price);
  }
  async placeOrderTransaction(itemName: string, user: string) {
    const [daosForTransaction, connection] =
      await this.transactionManager.getDAOsForTransaction(
        InventoryDAO,
        InvoiceDAO,
        AccountBalanceDAO,
      );

    const inventoryService = new InventoryService(daosForTransaction[0]);
    const invoiceService = new InvoiceService(daosForTransaction[1]);
    const paymentService = new PaymentService(daosForTransaction[2]);

    connection.query('BEGIN TRANSACTION');

    try {
      const price = await this.inventoryService.getPrice(itemName);
      await paymentService.checkAndChargePayment(user, price);
      await inventoryService.checkAndReduceStock(itemName);
      await invoiceService.provideInvoice(user, price);
    } catch (e: unknown) {
      connection.query('ROLLBACK');
      throw e;
    } finally {
      connection.release();
    }
  }
}
            </pre>

            here I've got a class which injects the transaction manager, grabs repositories from it, and then starts a transaction. 
            it then executes multiple repository functions all which utilize the same transaction, and then commits or rollsback. It also 
            releases the connection back to the pool
            
            <p>
            Here are links to the repos <a href="https://github.com/Jack-Gitter/tunes">golang repo</a>,  
            <a href="https://github.com/Jack-Gitter/TransactionInterceptor">ts repo</a>
            </p>
        </article>
    </main>
    <footer>
        <span class="date">JSWE at Sentinel Group</span>
    </footer>
</body>
</html>
