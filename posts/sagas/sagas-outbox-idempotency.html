<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sagas, Outbox, and Idempotency</title>
    <link rel="stylesheet" href="../../styles.css">
    <link rel="stylesheet" href="./sagas.css">
    <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
</head>
<body>
    <header>
        <h1>Sagas, Outbox, and Idempotency</h1>
    </header>
    <main>
        <article>
            <h1>How To Achieve Bulletproof Microservice Communication</h1>
            <p class="date">April 21, 2025</p>

            <p>
                Utilizing microserves in order to decouple a backend system into individually scalable and customizable applications is
                an effective method to build sustainable infrastructure. Pair this with dockerized services and an orchestration platform such as
                Kubernetes, and the infrastruture is robust
            </p>
            <p>
                With all these benefits, why would anyone ever decide to go in another direction? One of the biggest challenges when developing microservices
                is data integrity and consistency. Microsverices that utilize simple HTTP requests and isolated database transactions are bound to end up in
                an inconsistent state sooner or later, and I want to discuss how to avoid it.
            </p>

            <h2>The Setup</h2>

            <p>
                Consider an ecommerce business where you can place orders for various different items, and have them shipped to you around the world.
                This business might have services for keeping track of orders, managing inventory, and validating shipping requirements. These can be called
                the <span class="inline-service">Orders</span>, <span class="inline-service">Inventory</span>, and <span class="inline-service">Shipping</span> 
                microservices, respectively. When a user places an order, an <span class="inline-code">Order</span> entity is entered into the 
                database as a record in a pending state. Afterwards a message is sent to the <span class="inline-service">Inventory</span> service to 
                check whether there is enough inventory of the particular product. The <span class= "inline-service">Inventory</span> service then 
                creates a <span class="inline-code">Reservation</span> entity, and stores it in the database to keep track of the current status of the warehouse,
                after which it notifies the <span class="inline-service">Orders</span> of its success. Then, the <span class="inline-service">Orders</span> service 
                must reach out to the <span class="inline-service">Shipping</span> service to validate that the customer is within the allowed shipping range 
                for the specific product. Only after which, can the <span class="inline-service">Order</span> service then notify the 
                <span class="inline-service">Inventory</span> application delete the <span class="inline-code">Reservation</span> entity and corresponding 
                inventory, and set the <span class="inline-code">Order</span> entity status to approved. All of these steps together form a Saga, 
                a long running, evetually consistent business process. 
            </p>

            <h2>Queues</h2>

            <p>
                There are many different ways that different computers can communicate with one another. One of the most popular is the HTTP protocol With HTTP, 
                failed requests due to networking or service outages are hard to overcome. 
                <a href='https://en.wikipedia.org/wiki/Exponential_backoff'>Exponential Backoff</a> can be used to improve upon standard usage,
                although it achieves little of what could be done by a message broker. A message broker
                typically utilizes queues in order to route requests between services. Some of the biggest improvements seen when switching over to 
                using message queues for communication is decoupling of applications and increased durability. 
                A message queue can be thought of like a buffer. It holds messages until the reciever is ready. In the event of a message consumption failure,
                it can also re-queue messages. Below is a comparison between inter-service communication between two services, 
                the <span class="inline-service"> Orders</span> service and <span class="inline-service">Inventory</span> service. 
                <span class="inline-service">Orders</span> is attempting to send a message to <span class='inline-service'>Inventory</span>, 
                although <span class='inline-service'>Inventory</span> is currently unavailable.
            </p>

            <p>
                <div class="diagram">
                    <div class="title">1. Direct HTTP Communication</div>
                        <div>
                            <span class="box inline-service">Orders</span>
                            <span class="arrow">--❌--></span>
                            <span class="box crashed inline-service">Inventory</span>
                        </div>
                        <div class="note">Request to reserve inventory fails, order cannot be placed</div>

                        <div class="title">2. Queue-Based Communication</div>
                        <div>
                            <span class="box inline-service">Orders</span>
                            <span class="arrow">--✓--></span>
                            <span class="box queue">Message Queue</span>
                            <span class="arrow red">--⏳--></span>
                            <span class="box crashed inline-service">Inventory</span>
                        </div>
                        <div class="note">Service A continues working, queue holds message</div>

                        <div>
                            <span class="box inline-service">Orders</span>
                            <span class="arrow">     </span>
                            <span class="box queue">Message Queue</span>
                            <span class="arrow">--✓--></span>
                            <span class="box inline-service">Inventory</span>
                        </div>
                        <div class="note">Message delivered when Service B comes back online</div>
                    </div>

                <div class='sidenote'>
                    As a side note, messages between services should be "thin", meaning they should not contain a lot of data. One
                    of the huge benefits of microserices is that the <span class='inline-service'>Orders</span> service should know a lot about order details, 
                    but the <span class='inline-service'>Inventory</span> service might only need to know the product ID associated with the order. 
                    This results in a nice separation of concerns, leading to messages which only need to hold foreign references to entities 
                    owned by other services. 
                </div>

                With the implementation of queues inbetween our services, we have greatly improved our resiliance! However, consider the following scenario. The 
                Order service recieves a message to place a pending order. It writes the pending order to the database, then crashes before it can send the message. 
                The order service will come back online, and have a pending order in the database, but no message sent out to kick off our Saga. The end user will
                be left at some sort of waiting or error screen, and even worse our data is corrupted.
            </p>

            <h2>Outbox Pattern</h2>

            <p>
                An outbox is like a holding station for any outgoing messages that a service should send at some point, in order to be eventually consistent.
                This is best implemented as a database table, so that transactional consistency can be achieved between processing a request, and writing 
                a message to another service. Lets take the orders service example once more. An HTTP request comes in to place a pending order. The 
                Order service starts a transaction, writes this pending order to the database, and then writes a message to the InventoryReservationOutbox table. 
                The service then commits the transaction, so that both the message and the pending order are either both written, or neither are. On startup, 
                the Order service is set up to poll the InventoryReservationOutbox table for outgoing messages every X seconds. Once this polling functionality is 
                triggered, the message is pulled from the table, converted into JSON, and sent into the message queue for the Inventory service to process at a 
                later point. Once the message is in the queue, it is safe to be deleted from the InventoryReservationOutbox table. Most queues have configurable 
                durability, meaning if they crash with messages inside them they are able to enqueue them after coming back up again. 

                All done, right?! Wrong. Most message queues also have something called "at least once" delivery, meaning that messages might be sent to consumers
                such as the Inventory service more than once. If we send the same exact product reservation message to the Inventory service more than once, 
                we want the Inventory service to ignore any occurances of the message past the first 
            </p>
            

            <h2>Inbox Pattern</h2>
            <p>
                The inbox pattern, better known as the idempotent consumer pattern utilizes a similar approach to automic message processing as the outbox pattern,
                although in reverse. The inbox pattern writes incomming messages into a database table within a transaction which handles associated work to said
                message. If the work for the message succeeds, then the message is written to the inbox. Subsequent messages are ignored. 
                If the work fails, then we can reprocess the message at a later point. In our example, the Order service attaches the specific, auto incrementing 
                primary key for each specific order to the message it sends to the Inventory Service. This way, the inventory service is able to identify 
                duplicated messages, different from two messages with the same contents and different orderIds. It recieves the message, begins a transaction, 
                reserves inventory, writes the incomming message to the outbox, and a response message to the InventoryReservation outbox table, to later be sent
                to the Order service to continue on with the Saga
            </p>

            <h2>Compensating Actions</h2>
            <p>
                Up to this point, we've assumed that everything will go smoothy: which it won't. Sometimes half way through the saga, the 
                Shipping service will say that we cannot ship to the person, and we'll have a problem. We have these reserved inventory and pending product, 
                what to do? With a database, the solution would be simple. Abort the transaction, and rollback. With Sagas, the solution is similar: compensating
                actions. For each step in a Saga, there should always be a compensating action. For example, reserving 10 inventory for a specific product 
                would have the compenstaing action of releasing the 10 items for another person to purchase. If any step in the Saga fails, then 
                all previously successful steps must be compensated. This can be achieved by sending compensatino messages to all services who have 
                already performed some local transaction based on a recieved message earlier in the Saga.

                As a side note, it might at first seem adventageous to send out all Saga steps in parallel, to speed up the execution. I thought so too at first
                but as I looked into it a bit further, I realized a potential nasty data race. Lets say that the Order service sends out the ReserveInventory 
                and ValidateShipping messages both at once. The ValidateShipping message comes back uncessfull. What do we do? We can't yet compensate the 
                ReserveInventory step, because we don't know if it was succcessful or not!
            </p>



            <h2>The implementation</h2>

            <p>
                Now that we are all together on a theoretical level, lets talk implementation. I'll be using NodeJS, and NestJS, a framework for backend 
                services. My first thought was to implement a representation of a saga via an in-memory class. It would implement a ISagaOrchestrator  
                and have a list of steps, which implemented an ISagaStep interface. Below are the example classes

<div class="container">
  <div class="interface-title">ISagaOrchestrator Interface</div>
  <pre class="prettyprint lang-typescript">export interface ISagaOrchestrator {
  begin(): Promise<void>;
}</pre>
  
  <div class="interface-title">ISagaStep Interface</div>
  <pre class="prettyprint lang-typescript">export interface ISagaStep {
  invoke(): Promise<void>;
  compensate(): Promise<void>;
}</pre>
  
  <div class="class-title">OrderSagaOrchestrator Class</div>
  <pre class="prettyprint lang-typescript">export class OrderSagaOrchestrator implements ISagaOrchestrator<OrderSagaStep> {
  // list of steps in the saga
  constructor(private steps: ISagaStep[]) {}
  
  async begin(): Promise<void> {
    const succeededSteps: ISagaStep[] = []
    try {
      for (const step of steps) {
        const response = await step.invoke()
        if (!response.successful) {
          await compensate()
          return
        }
        succeededSteps.push(step)
      }
    } catch (e) {
      console.error(e)
      await compensate()
    }
  }
  
  private async compensate() {
    await Promise.all(succeededSteps.map(async (step) => {
      return await step.compensate()
    }))
  }
}</pre>
  
  <div class="class-title">ReserveInventoryStep Class</div>
  <pre class="prettyprint lang-typescript">export class ReserveInventoryStep implements ISagaStep {
  // example step, constructed with necessary data to send to quueue 
  constructor(
    private rabbitMQService: RMQService,
    private productId: number,
    private quantity: number
  ) {}
  
  /* send reserve inventory message, and wait for response. 
  Do not advance Saga until we get a response */
  invoke(): Promise<void> {
    await this.rabbitMQService.sendReserveInventoryMessage(productId, quantity) 
    return await this.rabbitMQService.listenForReserveInventoryResponse()
  }
  
  compensate(): Promise<void> {
    await this.rabbitMQService.compensateReserveInventoryMesssage(productId, quantity)
  }
}
... other steps</pre>


                This felt very organized and enterprised. Once a message came in, I would write the order and the InventoryReserve message to the database. Then, 
                every 5 seconds I would poll the outbox for new messages. If any were found, I would create a Saga with the needed steps, add it to the activeSagas
                array in the service class, and simply call the begin() method to kick off the first message and then delete the message from the outbox. The saga
                had code registered to listen on the corresponding queue for incomming response messages, and the world was great. Until I realized that I had 
                one of the most annoying kind of bugs, a data race. 

                Lets say for example we have two incomming order requests, which kicks off two sagas: Saga1 and Saga2. Saga1 and Saga2 both send out messages 
                to the InventoryReserve channel, and call the this.rabbitMQService.listenFoReserveInventoryResponse() method, meaning that they are sitting there,
                waiting from a message to come back from the rabbitMQ queue. This is actually whats known as the competing consumer pattern, 
                and can be great in some cases! A response will come to the queue, and either Saga1 or Saga2 can get the message, but only one of them. 
                In some cases, this allows for essentially a multithreading sort of functionality. But in 
                our scenario, it allows for Sagas to recieve the responses meant for other Sagas, meaning if Saga1's inventory request was denied but Saga2's wans't,
                Saga1 could recieve an successful message while Saga2 recieved the rejected message -- not good. So how do we remedy this? Back to the drawing board.

                We need one sort of "global" listener per response queue, and we need to be able to route it to the specific Saga it belongs to. I decided to 
                create a map, from orderId to saga and attach the orderId to the message. When a message comes back, we will simply look up the saga in the map,
                and call next step. 


<div class="interface-title">ISagaOrchestrator Interface</div>
  <pre class="prettyprint lang-typescript">export interface ISagaOrchestrator&lt;T&gt; {
  invokeStep(step: T): Promise&lt;void&gt;
  compensateStep(step: T): Promise&lt;void&gt;
 }
 </pre>
  
  <div class="interface-title">ISagaStep Interface</div>
  <pre class="prettyprint lang-typescript">export interface ISagaStep {
  invoke(): Promise&lt;void&gt;;
  compensate(): Promise&lt;void&gt;;
}</pre>
  
  <div class="interface-title">OrderSagaStep Enum</div>
  <pre class="prettyprint lang-typescript">export enum OrderSagaStep {
  INVENTORY_RESERVE,
  SHIPPING_VALIDATION,
  INVENTORY_REMOVE
}</pre>
  
  <div class="class-title">OrderSagaOrchestrator Class</div>
  <pre class="prettyprint lang-typescript">export class OrderSagaOrchestrator implements ISagaOrchestrator&lt;OrderSagaStep&gt; {
  // map to keep track of steps in the Saga
  constructor(
    private steps: Map&lt;OrderSagaStep, ISagaStep&gt;, 
    private successfulSteps: ISagaStep[]
  ) {}
  
  // invoke a singular step in the Saga, one at a time
  async invokeStep(step: OrderSagaStep): Promise&lt;void&gt; {
    const response = await steps.get(step).invoke()
    if (!response.successful) {
      await this.compensate()
    }
    successfulSteps.push(step)
  }
  
  // compensate a singular step in the Saga, one at a time
  async compensateStep(step: OrderSagaStep): Promise&lt;void&gt; {
    const response = await steps.get(step).compensate()
    if (!response.successful) {
      throw new Error('Failed to compensate')
    }
  }
}</pre>
  
  <div class="class-title">ReserveInventoryStep Class</div>
  <pre class="prettyprint lang-typescript">export class ReserveInventoryStep implements ISagaStep {
  constructor(
    private rabbitMQService: RMQService,
    private productId: number,
    private quantity: number
  ) {}
  
  invoke(): Promise&lt;void&gt; {
    await this.rabbitMQService.sendReserveInventoryMessage(productId, quantity) 
    // do not await response here!
  }
  
  compensate(): Promise&lt;void&gt; {
    await this.rabbitMQService.compensateReserveInventoryMesssage(productId, quantity)
  }
}</pre>
  
  <div class="class-title">OrdersController Class</div>
  <pre class="prettyprint lang-typescript">export class OrdersController implements ISagaStep {
  constructor(private rabbitmqService: RMQService) {}
  
  // all currently running Sagas
  private activeSagas: Map&lt;number, ISagaOrchestrator&gt;
  
  /* await all inventoryReserve message responses in a "global" place, 
  and route them to appropriate saga based on orderId */
  public reserveShippingResponseHandler() {
    const response = this.rabbitmqService.getInventoryResponse()
    const relatedSaga = this.runningSagas.get(response.orderId);
    
    if (!relatedSaga) {
      throw new InternalServerErrorException(
        `No running saga is related to the most recent message recieved!`,
      );
    }
    
    if (response.successfull) {
      // the reserve inventory step succeeded, start the next step in the saga
      relatedSaga.invokeStep(OrderSagaStep.SHIPPING_VALIDATION);
    } else {
      toRollback.forEach((step) => relatedSaga.compensateStep(OrderSagaStep.INVENTORY_RESERVE));
    }
  }
}</pre>

                Finally, we get to maybe the most obvious problem, the one that made me completely redesign the code: A server crash. If a server crashes with 
                active sagas, then we have messages that are going to eventually come back to the Orders application, with no corresponding saga. This means that
                we have to reconstruct the Sagas each time the application restarts, so that we can handle crashes properly. That was it, I had enough of 
                enterprise software object orientedness for one weekend. Rather, I ended up with the solution described in the article above. I simply
                created message handlers for each response queue, and I attached the orderId to every message to every service. This way, when the order
                service got a message, it could simply look up the order details, craft the next message with the data it knows about the order, and then 
                send it to the corresponding channel. No in-memory models cluttering up an already complex system
            </p>


            <h2>Code</h2>

            <p>
            Below is a link to a Github repository with the code implementation for the described example scenario. It utilizes NestJS, and dockerized
            Postgres and RabbitMQ instances. I was too lazy to configure a .env, so please clear off ports 3000, 3001, 3002, 1000, 1001, and 5672 
            <a href="https://github.com/Jack-Gitter/saga-outbox">Repo Link</a>
            </p>
        </article>
    </main>
    <footer>
        <span class="date">JSWE at Sentinel Group</span>
    </footer>
</body>
</html>
