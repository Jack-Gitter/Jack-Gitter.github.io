<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NFL OCTOBOT</title>
    <link rel="stylesheet" href="../../styles.css">
    <link rel="stylesheet" href="./nfloctobot.css">
    <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js?skin=desert"></script>
</head>
<body>
    <header>
        <h1>NFL OCTOBOT</h1>
    </header>
    <main>
        <article>
            <a href="https://jack-gitter.github.io" class="top-right-button">üè†</a>
            <h1>Twitter Bot for NFL Octopi</h1>
            <p class="date">October 10, 2025</p>
            <h2>Twitter Bot</h2>
            <p>
            An Octopus in the NFL is when one player gets both the touchdown, and the two point conversion. This term was coined by Mitch Goldich. 
            Please check out his <a href="https://www.mitchgoldich.com/octopus/">blog</a>, as without him this would not have been created.
            </p>
            
            <h2>Twitter Bot</h2>

            <h3>Purpose</h3>
                The intention is to tweet whenever an NFL player gets an octopus, or whenever the intended receiver who dropped the ball was the player who scored the touchdown. 
                <a href="https://x.com/NFLOCTOBOT">@NFLOCTOBOT</a> is the handle. If you want to support me and keep the bot running, you can <a href="https://buymeacoffee.com/jackgitter">donate</a>.
            <p>

            <h3>Process</h3>
            Creating a Twitter bot is pretty straightforward. After creating an account, you can go to the Twitter developer console to fetch all necessary
            tokens for auth, allowing access to API endpoints that are very well <a href="https://docs.x.com/x-api/introduction">documented</a>. 
            Because I used NodeJS, I was able to install a <a href="https://github.com/PLhery/node-twitter-api-v2">package</a> which aids in formatting the OAuth 
            request parameters, along with some other helper functions which wrap requests. Overall after instantiating the client, 
            making requests was pretty simple.
            
<pre class='prettyprint lang-typescript'>

export const twitterBaseUrl = `https://api.x.com/2`

export const getTwitterClient = async () => {
    return new TwitterApi({
      appKey: process.env.X_API_KEY as string,
      appSecret: process.env.X_API_KEY_SECRET as string,
      accessToken: process.env.X_ACCESS_TOKEN as string,
      accessSecret: process.env.X_ACCESS_TOKEN_SECRET as string
    });
}

...

await twitterClient.post(`${twitterBaseUrl}/tweets`, body)
</pre>
                
            <p>
                Twitter rate limits posts to 17 per 24 hours on the free tier. I don't anticipate this being a problem for tweeting about octopi.
            </p>
            
            
            <h2>ESPN Hidden API</h2>
            
            In order to get data on octopi, I'm using ESPN's hidden API, which ironically is 
            <a href="https://gist.github.com/akeaswaran/b48b02f1c94f873c6655e7129910fc3b">documented</a> better than many other APIs I've worked with.
            I'm performing HTTP short polling every minute in order to get up to date data, but also not overload ESPN's servers. The business logic is as follows

            <ol>
                <li>
                    Fetch all games for the current day
                </li>
                <li>
                    Fetch all plays for each game
                </li>
                <li>
                    Filter out scoring plays which are not two point conversions
                </li>
                <li>
                    Filter out scoring plays where the pat scorer, or intended pat scorer, was not the same as the touchdown scorer
                </li>
                <li>
                    Gather specifics about the player and play information
                </li>
                <li>
                    Save statistics and play information to the database for leaderboard, and deduplication purposes
                </li>
                <li>
                    Post to Twitter
                </li>
            </ol>
            
            The overall process is a bit more involved than that, but that gives a good enough high level overview to understand the flow.

            <h3>Data Modeling</h3>
            In my efforts to process ESPN data efficiently, I created my own notion of models for things such as games, scoring plays, athletes, and many other things.
            My data models are below



<pre class='prettyprint lang-typescript'>
export class Game {
    constructor(public gameId: number, public scoringPlays: ScoringPlayInformation[] = []) {}

    public deduplicateProcessedPlays(playIds: number[]) {
        const gameScoringPlays = this.scoringPlays?.length
        const playIdsSet = new Set(playIds)
        this.scoringPlays = this.scoringPlays?.filter(scoringPlay => {
            return !playIdsSet.has(scoringPlay.id)
        })
        const unprocessedGameScoringPlays = this.scoringPlays.length
        console.log(
            `Removed ${gameScoringPlays - unprocessedGameScoringPlays} already processed scoring plays from game ${this.gameId}`
        )

    }

    public filterScoringPlays() {
        const scoringPlays = this.scoringPlays?.filter((scoringPlay) => {
            return scoringPlay.isOctopus() || scoringPlay.isMissedOctopus()
        })
        console.log(`Found ${scoringPlays.length} new plays that are either octopi, or missed octopi`)
        return scoringPlays
    }
}
</pre>



<pre class='prettyprint lang-typescript'>
export class ScoringPlayInformation {
    constructor(
        public id: number,
        public participants: Athlete[],
        public pointAfterAttempt: PointAfterAttempt,
        public shortText: string,
        public text: string,
        public wallclock: Date,
        public octopusScorer?: Athlete,
        public octopusMissedAthlete?: Athlete,
    ) {}

    public isOctopus() {
        if (this.pointAfterAttempt.isTwoPointAttempt && this.pointAfterAttempt.success && this.pointAfterAttempt.scorer) {
            const tdScorer = this.participants.find((participant: Athlete) =&gt {
                return participant.type === SCORER_TYPE.TD_SCORER
            })
            return (tdScorer && this.pointAfterAttempt.scorer.id === tdScorer.id) 
        }
        return false
    }

    public isMissedOctopus() {
        if (this.pointAfterAttempt.isTwoPointAttempt && !this.pointAfterAttempt.success && this.pointAfterAttempt.scorer) {
            const tdScorer = this.participants.find((participant: Athlete) =&gt {
                return participant.type === SCORER_TYPE.TD_SCORER
            })
            return (tdScorer && this.pointAfterAttempt.scorer.id === tdScorer.id) 
        }
        return false

    }

    public async saveOctopusToDatabase(datasource: DataSource) {
        await datasource.transaction(async (entityManager: EntityManager) =&gt {
            const scoringPlayRepository = entityManager.getRepository(ScoringPlay)
            const octopusCountRepository = entityManager.getRepository(OctopusCount)
            const playerOctopusCountRepository = entityManager.getRepository(PlayerOctopusCount)
            if (this.octopusScorer) {
                const playerId = this.octopusScorer?.id
                const play = new ScoringPlay(this.id)
                await scoringPlayRepository.save(play)
                await octopusCountRepository.increment({id: 1}, 'count', 1)
                const playerOctopusCount = await playerOctopusCountRepository.findOneBy({id: playerId})
                if (!playerOctopusCount) {
                    const newPlayerOctopusCount = new PlayerOctopusCount(playerId, 1)
                    await playerOctopusCountRepository.save(newPlayerOctopusCount)
                } else {
                    playerOctopusCount.octopusCount += 1
                    await playerOctopusCountRepository.save(playerOctopusCount)
                }
                console.log(`Successfully saved the playId ${this.id}`)
                console.log(`Successfully updated player octopus count for player with id ${playerId}`)
                console.log(`Successfully updated global octopus count`)
            }
        })
    }

    public async saveFailedOctopusScoringPlayToDatabase(datasource: DataSource) {
        const scoringPlayRepository = datasource.getRepository(ScoringPlay)
        const scoringPlay = new ScoringPlay(this.id)
        await scoringPlayRepository.save(scoringPlay)
    }

    public async postFailedOctopusToTwitter(twitterClient: TwitterApi, datasource: DataSource) {

        const octopusCountRepository = datasource.getRepository(OctopusCount)
        const octopusCount = await octopusCountRepository.findOneBy({id: 1}) 
        if (this.octopusMissedAthlete && octopusCount) {
            await postFailedOctopusToTwitter(twitterClient, this.shortText, this.octopusMissedAthlete?.firstName, this.octopusMissedAthlete?.lastName, octopusCount?.count + 1)
        }

    }

    public async postOctopusToTwitter(twitterClient: TwitterApi, datasource: DataSource) {
        let playerOctopusCount = 0
        let globalOctopusCount = 0
        let playerOctopusRanking = 0
        let playerOctopusRankingTiedWith = 0
        await datasource.transaction(async (entityManager) =&gt {
            if (this.octopusScorer)  {
                const playerOctopusCountRepository = entityManager.getRepository(PlayerOctopusCount)
                const octopusCountRepository = entityManager.getRepository(OctopusCount)

                const octopusCount = await octopusCountRepository.findOneBy({id: 1})
                const playerOctopus = await playerOctopusCountRepository.findOneBy({id: this.octopusScorer.id})

                if (playerOctopus && octopusCount) {
                    globalOctopusCount = octopusCount.count
                    playerOctopusCount = playerOctopus.octopusCount
                    playerOctopusRanking = await playerOctopusCountRepository.count({where: {octopusCount: MoreThan(playerOctopusCount)}}) + 1
                    playerOctopusRankingTiedWith = await playerOctopusCountRepository.count({where: {octopusCount: Equal(playerOctopusCount)}}) - 1
                }

            }
        })

        if (this.octopusScorer) {
            return await postOctopusToTwitter(
                twitterClient, 
                this.shortText,
                this.octopusScorer?.firstName, 
                this.octopusScorer?.lastName, 
                playerOctopusCount, 
                globalOctopusCount,
                playerOctopusRanking,
                playerOctopusRankingTiedWith
            )
        }
    }
    public async populateOctopusPlayerInformation() {
        this.octopusScorer = this.pointAfterAttempt.scorer
    }

    public async populateFailedOctopusPlayerInformation() {
        this.octopusMissedAthlete = this.pointAfterAttempt.scorer
    }
}
</pre>



<pre class='prettyprint lang-typescript'>
export class PointAfterAttempt {
    constructor(public success: boolean, public isTwoPointAttempt: boolean, public scorer?: Athlete) { }
}
</pre>


<pre class='prettyprint lang-typescript'>
export class Athlete {
    constructor(public firstName: string, public lastName: string, public id: number, public type: string) {}
}
</pre>

If you have critiques of my data model, <a href="https://www.youtube.com/watch?v=sEHpcMYfd3c">well so do I</a>. 
This bot was made over the course of a couple of days, and was a fun side project. 
I'm not particularly invested in making the code as perfect as possible.
In particular, I feel that some of the logic is overcomplicated, and posting to Twitter should not be encompassed within the data model of a scoring play, but rather
externally defined and parameterized with a scoring play. 


<h3>Anti-Corrpution Layer</h3>
In order to populate my data models, I have an anti-corruption layer which helps to query the ESPN API and create said models.

<pre class='prettyprint lang-typescript'>export const getScoringPlayInformation = async (gameId: number, scoringPlayIds: number[]) => {
    if (scoringPlayIds) {
        return await Promise.all(scoringPlayIds.map(async (scoringPlayId) =&gt {
            const url = `https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/${gameId}/competitions/${gameId}/plays/${scoringPlayId}`
            const result = await fetch(url)
            const scoringPlayInformationResponse: ScoringPlayInformationResponse = await result.json()
            return scoringPlayInformationResponse
        }))
    }
}

export const getScoringPlayAthletes = async (scoringPlay: ScoringPlayInformationResponse) =&gt {
        const athletes: Athlete[] = []
        if (scoringPlay?.participants) {
            await Promise.all(scoringPlay?.participants.map(async (participant) =&gt {
                const athleteResponse = await getAtheleteInformation(participant.athlete.$ref)
                if (athleteResponse) {
                    const athlete = new Athlete(athleteResponse.firstName, athleteResponse.lastName, athleteResponse.id, participant.type)
                    athletes.push(athlete)
                }
            }))
        }
        return athletes
}

export const getScoringPlayPat = async (scoringPlay: ScoringPlayInformationResponse) =&gt {
        const isTwoPointAttempt = scoringPlay?.pointAfterAttempt?.id === 15 || scoringPlay?.pointAfterAttempt?.id === 16 || scoringPlay?.text?.toLowerCase()?.includes('two point')

        const twoPointAttemptSuccess = 
                scoringPlay?.pointAfterAttempt?.value === 2 || 
                (scoringPlay?.text?.toLowerCase()?.includes('two-point') && 
                scoringPlay?.text?.toLowerCase()?.includes('attempt succeeds'))

        const participant = scoringPlay?.participants.find((participant: ParticipantResponse) =&gt {
            return participant.type === SCORER_TYPE.PAT_SCORER
        })

        const patScorerResponse = await getAtheleteInformation(participant?.athlete.$ref)

        let patScorer = undefined

        if (patScorerResponse && participant) {
            patScorer = new Athlete(patScorerResponse.firstName, patScorerResponse.lastName, patScorerResponse.id, participant.type)
        }

        return new PointAfterAttempt(twoPointAttemptSuccess, isTwoPointAttempt, patScorer)

}

export const getGameInformation = async (gameId: number) =&gt {

    const scoringPlayIds = await getGameScoringPlayIds(gameId)
    const scoringPlayInformationResponse = await getScoringPlayInformation(gameId, scoringPlayIds)

    let scoringPlays: ScoringPlayInformation[] = []
    if (scoringPlayInformationResponse) {
        scoringPlays = await Promise.all(scoringPlayInformationResponse.map(async (scoringPlay) =&gt {
            const scoringPlayAthletes = await getScoringPlayAthletes(scoringPlay)
            const pointAfterAttempt = await getScoringPlayPat(scoringPlay)
            return new ScoringPlayInformation(scoringPlay.id, scoringPlayAthletes, pointAfterAttempt, scoringPlay.shortText, scoringPlay.text, new Date(scoringPlay.wallclock))
        }))
    }

    return new Game(gameId, scoringPlays)

}</pre>

    Again, the code is not perfect. There should be enums for readability, cleaner logic, and improvements around error handling.

            <h2>Postgres Database</h2>
            <p>
            For persistence, I'm using Postgres and Typeorm. It was easy enough to create a couple of entities that would keep track of all of the necessary information. 
            Since I'm paying to host the database myself, I've kept the models quite slim, relying only on ESPN internal identifiers to uniquely identify plays, players, 
            and other things. 



<pre class='prettyprint lang-typescript'>
@Entity()
export class OctopusCount {

    constructor(id: number, count: number) {
        this.id = id
        this.count = count
    }

    @Column({primary: true})
    id: number

    @Column({type: 'int'})
    count: number

}
</pre>

<pre class='prettyprint lang-typescript'>
@Entity()
export class ScoringPlay {

    constructor(id: number) {
        this.id = id
    }

    @Column({primary: true, type: 'bigint'})
    id: number
}
</pre>

<pre class='prettyprint lang-typescript'>
@Entity()
export class PlayerOctopusCount {

    constructor(id: number, octopusCount: number = 0) {
        this.id = id
        this.octopusCount = octopusCount
    }

    @Column({primary: true, type: 'bigint'})
    public id: number

    @Column({type: 'int', default: 0})
    public octopusCount: number

}
</pre>


            <h3>Leaderboard and Historical Data</h3>
            In order to differentiate my bot from other "competitors", I decided to include statistics in the form of a leaderboard, and an all time player octopus count. 
            The entities which aid me in this are <span class="inline-code">PlayerOctopusCount</span> and <span class='inline-code'>OctopusCount</span>. 
            Each time a player gets an octopus, these two tables
            are updated, and therefore allows me to gather relevant statistics when going to post to Twitter. Additionally, the <span class="inline-code">ScoringPlay</span> 
            entity is vital.
            This helps to deduplicate already processed scoring plays, so no octopus or missed octopus is posted twice.
            <h2>Docker</h2>

            <p>
                The entire project is containerized, running in Docker for ease of deployment and system independence. Both a local Postgres and application instance can be spun
                up with the docker compose file.

<pre class='prettyprint lang-typescript'>
services:
  app:
    build:
      context: .
      dockerfile: Dockerfile
    tty: true
    profiles: [app, all]
    environment:
      X_API_KEY: ${X_API_KEY}
      X_API_KEY_SECRET: ${X_API_KEY_SECRET}
      X_BEARER_TOKEN: ${X_BEARER_TOKEN}
      X_ACCESS_TOKEN: ${X_ACCESS_TOKEN}
      X_ACCESS_TOKEN_SECRET: ${X_ACCESS_TOKEN_SECRET}
      X_CLIENT_ID: ${X_CLIENT_ID}
      X_CLIENT_SECRET: ${X_CLIENT_SECRET}
      PG_USER: ${PG_USER}
      PG_PASS: ${PG_PASS}
      PG_DB: ${PG_DB}
      PG_HOST: ${PG_HOST}
      PG_PORT: ${PG_PORT}
      STARTING_OCTOPUS_COUNT: ${STARTING_OCTOPUS_COUNT}
      PORT: ${PORT}
      RECOVERY_MODE: ${RECOVERY_MODE}
      RECOVERY_START_DATE: ${RECOVERY_START_DATE}
      RECOVERY_END_DATE: ${RECOVERY_END_DATE}
  db:
    image: postgres:15
    profiles: [pg, all]
    restart: always
    environment:
      POSTGRES_USER: ${PG_USER}
      POSTGRES_PASSWORD: ${PG_PASS}
      POSTGRES_DB: ${PG_DB}
    ports: 
      - 5433:5432
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:
</pre>

Additionally, the image is built and deployed to Docker Hub, to make the deployment process easy.
            <h2>Render Deployment</h2>

            <a href="https://render.com/">Render</a> offers a hosted Postgres solution, which is extremely easy to get up and running. 
            Additionally, the bot is deployed via a Render background worker, by simply pointing to the container repository living on Docker Hub. 
            last piece of the puzzle is to fill out the necessary environment variables to connect to the database, access Twitter, and set up the application.
            The total cost of deployment will most likely not exceed $15 dollars a month.

            <h3>Github Action</h3>
            In order to build and push the docker image automatically, I have set up a simple github action that performs this on merges to the main branch


<pre class='prettyprint lang-typescript'>
name: Docker Image CI

on:
  push:
    branches:
      - main

jobs:
  build-and-push:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: jackandrewgitter/nfl_octobot:latest
</pre>

This as well requires additional secrets, particularly the docker hub username and password to allow the CLI to push the image on my behalf.

<br>

            <h2>Donations</h2>
                
            Donations are all performed via <a href="https://buymeacoffee.com/jackgitter">buy me a cofee</a>. In order to keep track of all donations, I've created 
            another entity

<pre class='prettyprint lang-typescript'>
@Entity('donations')
export class Donation {

    constructor(
        id: number, 
        money: number, 
        donatorName: string, 
        unixTimestamp: number
    ) {
        this.id = id
        this.money = money
        this.donatorName = donatorName
        this.timestamp = new Date(unixTimestamp * 1000)
    }

    @Column({primary: true, type: 'bigint'})
    id: number

    @Column({type: 'float'})
    money: number

    @Column({name: 'donator_name'})
    donatorName: string

    @Column()
    timestamp: Date

}
</pre>

        When a donation occurs, a webhook set up with buy me a cofee calls an endpoint in my application which creates a corresponding donation record in the database.



<pre class='prettyprint lang-typescript'>
    app.post('/hook', async (req, res) =&gt {
        if (!datasource.isInitialized) {
            await datasource.initialize()
        }

        const donationRepository = datasource.getRepository(Donation)

        const body: BuyMeACoffeeWebhook = req.body

            
        const valid = isSignatureValid(req)
        if (!valid) {
            res.status(403).send(`Invalid Signature`)
            return
        }

        console.log(`Donation Received! ${JSON.stringify(body)}`)

        const money = body?.data?.amount
        const name = body?.data.supporter_name
        const currency = body?.data?.currency
        const unixTimestamp = body?.data?.created_at

        const usdMoney = await convertToUSD(money, currency)

        const donation = new Donation(body?.data?.id, usdMoney, name, unixTimestamp)

        await donationRepository.save(donation)

        console.log(`Donation saved to database`)

        res.send(`Saved Donation`)
    })
</pre>

In order to verify that the request is sent by the intended source, buy me a coffee attaches a signed HTTP header in the request. The <span class="inline-code">isSignatureValid</span>
method utilizes a secret value provided by buy me a coffee and set as an environment variable which verifies the signature against the request body. If all is aligned, then 
the donation amount gets normalized to USD, and the record gets saved to the database. Every last day of the month, a cron job runs which aggregates donation data, and 
posts to twitter


<pre class='prettyprint lang-typescript'>
    cron.schedule('0 0 28-31 * *', async () =&gt {
        const today = new Date();
        const tomorrow = new Date(today);
        tomorrow.setDate(today.getDate() + 1);

        if (tomorrow.getMonth() !== today.getMonth()) {
          console.log('üìÖ Running monthly donation summary...');

          const highestAllTime = await getHighestAllTimeDonator(datasource);
          const highestMonthly = await getHighestMonthlyDonator(datasource);
          const totalMonthlyDonations = await getMonthlyDonationCount(datasource)

          console.log(`highest all time: ${JSON.stringify(highestAllTime)}`)
          console.log(`highest monthly: ${JSON.stringify(highestMonthly)}`)
          console.log(`total monthly: ${JSON.stringify(totalMonthlyDonations)}`)

          await tweetDonations(
                twitterClient, 
                highestAllTime?.donatorName, 
                highestAllTime?.total, 
                highestMonthly?.donatorName,
                highestMonthly?.total,
                totalMonthlyDonations?.total
          )
        }
    });
</pre>


            <a href="https://github.com/jack-gitter/nfl_octobot">Repo Link</a> 
        </article>
    </main>
    <footer>
        <span class="date">SWE @ Sentinel Group</span>
    </footer>
</body>
</html>
