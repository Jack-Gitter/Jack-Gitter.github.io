<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NFL OCTOBOT</title>
    <link rel="stylesheet" href="../../styles.css">
    <link rel="stylesheet" href="./nfloctobot.css">
    <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js?skin=desert"></script>
</head>
<body>
    <header>
        <h1>NFL OCTOBOT</h1>
    </header>
    <main>
        <article>
            <a href="https://jack-gitter.github.io" class="top-right-button">üè†</a>
            <h1>Twitter Bot for NFL Octopi</h1>
            <p class="date">October 10, 2025</p>
            <h2>Twitter Bot</h2>
            <p>
            An Octopus in the NFL is when one player gets both the touchdown, and the two point conversion. This term was coined by Mitch Goldich. 
            Please check out his <a href="https://www.mitchgoldich.com/octopus/">blog</a>, as without him this would not have been created.
            </p>
            
            <h2>Twitter Bot</h2>

            <h3>Purpose</h3>
                The intention is to tweet whenever an NFL player gets an octopus, or whenever the intended receiver who dropped the ball was the player who scored the touchdown. 
                <a href="https://x.com/NFLOCTOBOT">@NFLOCTOBOT</a> is the handle. If you want to support me and keep the bot running, you can <a href="https://buymeacoffee.com/jackgitter">donate</a>.
            <p>

            <h3>Process</h3>
            Creating a Twitter bot is pretty straightforward. After creating an account, you can go to the Twitter developer console to fetch all necessary
            tokens for auth, allowing access to API endpoints that are very well <a href="https://docs.x.com/x-api/introduction">documented</a>. 
            Because I used NodeJS, I was able to install a <a href="https://github.com/PLhery/node-twitter-api-v2">package</a> which aids in formatting the OAuth 
            request parameters, along with some other helper functions which wrap requests. Overall after instantiating the client, 
            making requests was pretty straightforward
            
<pre class='prettyprint lang-typescript'>

export const twitterBaseUrl = `https://api.x.com/2`

export const getTwitterClient = async () => {
    return new TwitterApi({
      appKey: process.env.X_API_KEY as string,
      appSecret: process.env.X_API_KEY_SECRET as string,
      accessToken: process.env.X_ACCESS_TOKEN as string,
      accessSecret: process.env.X_ACCESS_TOKEN_SECRET as string
    });
}

...

await twitterClient.post(`${twitterBaseUrl}/tweets`, body)
</pre>
                
            <p>
                Twitter rate limits posts to 17 per 24 hours on the free tier. I don't anticipate this being a problem for tweeting about octopi.
            </p>
            
            
            <h2>ESPN Hidden API</h2>
            
            In order to get data on octopi, I'm using ESPN's hidden API, which ironically is 
            <a href="https://gist.github.com/akeaswaran/b48b02f1c94f873c6655e7129910fc3b">documented</a> better than many other APIs I've worked with.
            I'm performing HTTP short polling every minute in order to get up to date data, but also not overload ESPN's servers. The business logic is as follows

            <ol>
                <li>
                    Fetch all games for the current day
                </li>
                <li>
                    Fetch all plays for each game
                </li>
                <li>
                    Filter out scoring plays which are not two point conversions
                </li>
                <li>
                    Filter out scoring plays where the pat scorer, or intended pat scorer, was not the same as the touchdown scorer
                </li>
                <li>
                    Gather specifics about the player and play information
                </li>
                <li>
                    Save statistics and play information to the database for leaderboard, and deduplication purposes
                </li>
                <li>
                    Post to Twitter
                </li>
            </ol>

            <h2>Postgres Database</h2>
            <p>
            For persistence, I'm using Postgres and Typeorm. It was easy enough to create a couple of entities that would keep track of all of the necessary information. 
            Since I'm paying to host the database myself, I've kept the models quite slim, relying only on ESPN internal identifiers to uniquely identify plays, players, 
            and other things. 



<pre class='prettyprint lang-typescript'>
@Entity()
export class OctopusCount {

    constructor(id: number, count: number) {
        this.id = id
        this.count = count
    }

    @Column({primary: true})
    id: number

    @Column({type: 'int'})
    count: number

}
</pre>

<pre class='prettyprint lang-typescript'>
@Entity()
export class ScoringPlay {

    constructor(id: number) {
        this.id = id
    }

    @Column({primary: true, type: 'bigint'})
    id: number
}
</pre>

<pre class='prettyprint lang-typescript'>
@Entity()
export class PlayerOctopusCount {

    constructor(id: number, octopusCount: number = 0) {
        this.id = id
        this.octopusCount = octopusCount
    }

    @Column({primary: true, type: 'bigint'})
    public id: number

    @Column({type: 'int', default: 0})
    public octopusCount: number

}
</pre>



            
            <p>
            <h2>Docker</h2>

            <p>
                The entire project is containerized, running in Docker for ease of deployment and system independence. Both a local Postgres and application instance can be spun
                up with the docker compose file.

<pre class='prettyprint lang-typescript'>
services:
  app:
    build:
      context: .
      dockerfile: Dockerfile
    tty: true
    profiles: [app, all]
    environment:
      X_API_KEY: ${X_API_KEY}
      X_API_KEY_SECRET: ${X_API_KEY_SECRET}
      X_BEARER_TOKEN: ${X_BEARER_TOKEN}
      X_ACCESS_TOKEN: ${X_ACCESS_TOKEN}
      X_ACCESS_TOKEN_SECRET: ${X_ACCESS_TOKEN_SECRET}
      X_CLIENT_ID: ${X_CLIENT_ID}
      X_CLIENT_SECRET: ${X_CLIENT_SECRET}
      PG_USER: ${PG_USER}
      PG_PASS: ${PG_PASS}
      PG_DB: ${PG_DB}
      PG_HOST: ${PG_HOST}
      PG_PORT: ${PG_PORT}
      STARTING_OCTOPUS_COUNT: ${STARTING_OCTOPUS_COUNT}
      PORT: ${PORT}
      RECOVERY_MODE: ${RECOVERY_MODE}
      RECOVERY_START_DATE: ${RECOVERY_START_DATE}
      RECOVERY_END_DATE: ${RECOVERY_END_DATE}
  db:
    image: postgres:15
    profiles: [pg, all]
    restart: always
    environment:
      POSTGRES_USER: ${PG_USER}
      POSTGRES_PASSWORD: ${PG_PASS}
      POSTGRES_DB: ${PG_DB}
    ports: 
      - 5433:5432
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:
</pre>

Additionally, the image is built and deployed to Docker Hub, to make the deployment process easy.
            <h2>Render Deployment</h2>

            <a href="https://render.com/">Render</a> offers a hosted Postgres solution, which is extremely easy to get up and running. 
            Additionally, the bot is deployed via a Render background worker, by simply pointing to the container repository living on Docker Hub. The 
            last piece of the puzzle is to fill out the necessary environment variables to connect to the database, access Twitter, and set up the application.
            The total cost of deployment will most likely not exceed $15 dollars a month.
            <a href="https://github.com/jack-gitter/nfl_octobot">Repo Link</a> 
        </article>
    </main>
    <footer>
        <span class="date">SWE @ Sentinel Group</span>
    </footer>
</body>
</html>
