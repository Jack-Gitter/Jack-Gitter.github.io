<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Orchestration Sagas</title>
    <link rel="stylesheet" href="../../styles.css">
    <link rel="stylesheet" href="./orchestration_sagas.css">
    <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js?skin=desert"></script>
</head>
<body>
    <header>
        <h1>Orchestration Sagas</h1>
        <p class="date">December 19, 2025</p>
    </header>
    <main>
        <article>
            <a href="https://jack-gitter.github.io" class="top-right-button">üè†</a>
			<h2>Recap</h2>
            <p>
				This is a small continuation of my other work around sagas, in which I first attempted to 
				implement a orchestration based saga, but restorted to a choreography based saga. I outlined
				all of the patterns and techniques revolvign around robust microservice communication, 
				and some of the challenges I had along the way in another 
				<a href="https://jack-gitter.github.io/posts/sagas/sagas-outbox-idempotency.html">post</a>.
				Although the implementation worked, I was not satisfied with both the code on an organizational 
				level, and the choreography based approach. 
				For this implementation, I've decided to utilize all of the same robustness techniques, although
				created a more modular, clean implementation of an ochestration based saga.             </p>

			<h2>General Patterns, High Level Overview</h2>
			<p>
			This post will not go into great detail about design patterns used, although I will give a brief overview 
			for clarity. The main patterns used to communicate between microservices in this are: 
			<a href="https://microservices.io/patterns/data/saga.html">saga</a>,
			<a href="https://microservices.io/patterns/communication-style/idempotent-consumer.html">idempotent consumer</a>,
			and 
			<a href="https://microservices.io/patterns/data/transactional-outbox.html">transactional outbox</a>.
			I also use some simple OOP patterns, such as the 
			<a href="https://refactoring.guru/design-patterns/factory-method">factory</a> 
			and <a href="https://refactoring.guru/design-patterns/builder">builder</a>.
			</p>

			<h2>Infrastructure</h2>
				This project depends on a couple of different infrastructure technologies.

				<ul>
					<li>
						<span class="desc">Postgres</span>: Used for persistance of the saga, inbox and outbox messages, 
						and overall "work" that individiual microservices needed to acomplish as apart of the saga.
					</li>
					<li>
						<span class="desc">	RabbitMQ</span>: Facilitates messaging between microservices
					</li>
					<li>
						<span class="desc">Docker</span>: Used in order to easily spin up the infrastructure dependencies
					</li>
				<ul>
			<h2>Orders, Inventory, and Shipping services</h2>
			The overall goal of this project is to utilize a crash-resilient orchestration based saga 
			to create a microservice system that is eventually consistent. Regardless of service crashes at any instant, 
			whether it be the orchestrator or worker nodes. The simulated environment for this 
			is an oversimplified ecommerce system with three microservices: orders, inventory, and shipping. 
			<h3>Orders Service</h3>
			The orders service acts as the entrypoint for new requests, and is therefore the saga orchestrator.
			Requests reach the orders service via HTTP. For simplicity, requests only contain a 
			productId and a quantity field located in a JSON body. After receiving the request, it creates an order
			in a pending state, and a new orders saga. Throughout the entire process, the orders service
			continues to facilitate messages between the other services until the order is shipped, 
			after which it will finalize the order status. If anything goes wrong along the way, 
			the orders service is responsible for canceling the order by updating its local database, and sending messages
			to microservices which need to rollback any successful changes that were performed.
			<h3>Inventory Service</h3>
			The inventory service is responsible for managing how much of a specific product is available. In theory is would 
			validate there is enough product for the given order requested, and remove the inventory from the system. In reality, 
			most of this project was centered around the orchestrator, so the inventory service performs "fake" work, and fails
			10% of the time.
			<h3>Shipping Service</h3>
			The shipping service is responsible for shipping the product once the inventory has been removed. This would be the last 
			step in the process, besides finalizing the order in the orders service. Once again, this service doesn't do much 
			of anything, besides sending messages back to the orchestrator and failing 10% of the time
			<h2>Saga Step Interface</h2>
			To parse the implementation, we will work our way up from the smallest buildling block to the largest. Firstly, we'll 
			talk about the saga step interface. Thankfully, it is quite minimal. There is an invoke function and a compensate function. 
			When implemented, the invoke function's purpose is to perform the work of the step. The compensate function 
			should revert whatever occured during the invoke step for rollback purposes. There is also a field on the step, 
			which is helpful in restoring sagas from the database. More on this later.

<pre class='prettyprint lang-typescript'>
import { STEP } from "../../../db/entities/types"

export interface SagaStepInterface&ltT, U&gt {
  step: STEP
  invoke(data: T): Promise&ltvoid&gt
  compenstate(data: U): Promise&ltvoid&gt
}
</pre>

	<h2>OrderSaga Steps</h2>
	In order to implement the saga, some concrete steps are required. The following are the steps created 
	for the order saga. All steps must be idempotent, and all actions have to occur in the same database 
	transaction in order to achieve consistency.
	<h3>Create Order</h3>


<pre class='prettyprint lang-typescript'>
export class CreateOrderStep implements SagaStepInterface&ltOrderSagaStepData, OrderSagaStepData&gt {
  public step: STEP = STEP.CREATE_ORDER
  constructor(private datasource: DataSource) {}

  async invoke(data: OrderSagaStepData): Promise&ltvoid&gt {
    console.log(`creating order with id ${data.orderId}`)
    await this.datasource.transaction(async manager =&gt {
    const orderRepository = manager.getRepository(Order)
    const outboxRepository = manager.getRepository(OutboxMessage)
    const orderSagaRepository = manager.getRepository(OrderSagaEntity)

    const existingOrder = await orderRepository.findOneBy({orderId: data.orderId})
    if (existingOrder) {
      console.log(`already created order with id ${data.orderId}, skipping`)
      return
    }

    const order = new Order(data.orderId, data.productId, data.quantity)
    const outboxMessage = new OutboxMessage(data.orderId, data.productId, data.quantity, OUTBOX_MESSAGE_TYPE.REMOVE_INVENTORY_LOCAL)
    const orderSagaEntity = new OrderSagaEntity(data.orderId, data.quantity, data.productId, STEP.CREATE_ORDER)

    await orderRepository.save(order)
    await outboxRepository.save(outboxMessage)
    await orderSagaRepository.save(orderSagaEntity)
})
 }

  async compenstate(data: OrderSagaStepData): Promise&ltvoid&gt {
	console.log(`compensating create order step`)
	await this.datasource.transaction(async manager =&gt {
      const orderRepository = manager.getRepository(Order)
      const sagaRepository = manager.getRepository(OrderSagaEntity)

      const sagaEntity = new OrderSagaEntity(data.orderId, data.productId, data.quantity, STEP.COMPENSATE)
      const existingOrder = await orderRepository.findOneBy({orderId: data.orderId})
      existingOrder.status = ORDER_STATUS.CANCELED

      await sagaRepository.save(sagaEntity)
      await orderRepository.save(existingOrder)
    })
  }
}
</pre>

<h3>Remove Inventory</h3>

<pre class='prettyprint lang-typescript'>
export class RemoveInventoryStep implements SagaStepInterface&ltOrderSagaStepData, OrderSagaStepData&gt {

  public step: STEP = STEP.REMOVE_INVENTORY

  constructor(private datasource: DataSource) {}

  async invoke(data: OrderSagaStepData): Promise&ltvoid&gt {
    console.log(`removing inventory for order with id ${data.orderId}`)
    await this.datasource.transaction(async manager =&gt {
      const inboxRepository = manager.getRepository(InboxMessage)
      const existingMessage = await inboxRepository.findOneBy({id: data.messageId, messageType: INBOX_MESSAGE_TYPE.REMOVE_INVENTORY_LOCAL})
      if (existingMessage) {
        console.log(`already removed inventory for order with id ${data.orderId}, skipping`)
        return
      }
      const outboxRepository = manager.getRepository(OutboxMessage)
      const sagaRepository = manager.getRepository(OrderSagaEntity)

      const inboxMessage = new InboxMessage(data.messageId, data.orderId, INBOX_MESSAGE_TYPE.REMOVE_INVENTORY_LOCAL, true)
      const outboxMessage = new OutboxMessage(data.orderId, data.productId, data.quantity, OUTBOX_MESSAGE_TYPE.REMOVE_INVENTORY)
      const sagaEntity = new OrderSagaEntity(data.orderId, data.productId, data.quantity, STEP.REMOVE_INVENTORY)

      await inboxRepository.save(inboxMessage)
      await outboxRepository.save(outboxMessage)
      await sagaRepository.save(sagaEntity)
    })
  }

  async compenstate(data: OrderSagaStepData): Promise&ltvoid&gt {
    console.log(`compensating remove inventory step`)
    await this.datasource.transaction(async manager =&gt {
      const outboxRepository = manager.getRepository(OutboxMessage)
      const existingMessage = await outboxRepository.findOneBy({orderId: data.orderId, messageType: OUTBOX_MESSAGE_TYPE.RESTORE_INVENTORY})
      if (existingMessage) {
        console.log('already compensated, skipping')
        return
      }

      const outboxMessage = new OutboxMessage(data.orderId, data.productId, data.quantity, OUTBOX_MESSAGE_TYPE.RESTORE_INVENTORY)

      await outboxRepository.save(outboxMessage)
    })
  }
}
</pre>

<h3>Ship Order</h3>


<pre class='prettyprint lang-typescript'>
export class ShipOrderStep implements SagaStepInterface&ltOrderSagaStepData, OrderSagaStepData&gt {

  public step: STEP = STEP.SHIP_ORDER

  constructor(private datasource: DataSource) {}

  async invoke(data: OrderSagaStepData): Promise&ltvoid&gt {
    console.log(`shipping order for order with id ${data.orderId}`)
    await this.datasource.transaction(async manager =&gt {
      const inboxRepository = manager.getRepository(InboxMessage)
      const existingMessage = await inboxRepository.findOneBy({id: data.messageId, messageType: INBOX_MESSAGE_TYPE.INVENTORY_RESPONSE})
      if (existingMessage) {
        console.log(`already shipped order for order with id ${data.orderId}, skipping`)
        return
      }
      const outboxRepository = manager.getRepository(OutboxMessage)
      const sagaRepository = manager.getRepository(OrderSagaEntity)

      const inboxMessage = new InboxMessage(data.messageId, data.orderId, INBOX_MESSAGE_TYPE.INVENTORY_RESPONSE, true)
      const outboxMessage = new OutboxMessage(data.orderId, data.productId, data.quantity, OUTBOX_MESSAGE_TYPE.SHIP_ORDER)
      const sagaEntity = new OrderSagaEntity(data.orderId, data.productId, data.quantity, STEP.SHIP_ORDER)

      await inboxRepository.save(inboxMessage)
      await outboxRepository.save(outboxMessage)
      await sagaRepository.save(sagaEntity)
    })
  }
  async compenstate(data: OrderSagaStepData): Promise&ltvoid&gt {
    console.log(`compensating ship order step`)
    await this.datasource.transaction(async manager =&gt {
      const outboxRepository = manager.getRepository(OutboxMessage)

      const existingMessage = await outboxRepository.findOneBy({orderId: data.orderId, messageType: OUTBOX_MESSAGE_TYPE.SHIP_ORDER_CANCEL})
      if (existingMessage) {
        console.log('already compensated, skipping')
        return
      }
      const outboxMessage = new OutboxMessage(data.orderId, data.productId, data.quantity, OUTBOX_MESSAGE_TYPE.SHIP_ORDER_CANCEL)

      await outboxRepository.save(outboxMessage)
    })
  }
}
</pre>

<h3>Finalizing Order</h3>
<pre class='prettyprint lang-typescript'>
export class FinalizeOrderStep implements SagaStepInterface&ltOrderSagaStepData, OrderSagaStepData&gt {

  public step: STEP = STEP.FINALIZE_ORDER

  constructor(private datasource: DataSource) {}

  async invoke(data: OrderSagaStepData): Promise&ltvoid&gt {
    console.log(`finalizing order with id ${data.orderId}`)
    await this.datasource.transaction(async manager =&gt {
      const inboxRepository = manager.getRepository(InboxMessage)
      const existingMessage = await inboxRepository.findOneBy({id: data.messageId, messageType: INBOX_MESSAGE_TYPE.SHIPPING_RESPONSE})
      if (existingMessage) {
        console.log(`already finalized order with id ${data.orderId}, skipping`)
        return;
      }

      const sagaRepository = manager.getRepository(OrderSagaEntity)
      const orderRepository = manager.getRepository(Order)

      const inboxMessage = new InboxMessage(data.messageId, data.orderId, INBOX_MESSAGE_TYPE.SHIPPING_RESPONSE, true)
      const sagaEntity = new OrderSagaEntity(data.orderId, data.productId, data.quantity, STEP.FINALIZE_ORDER)
      const order = await orderRepository.findOneBy({orderId: data.orderId})
      order.status = ORDER_STATUS.FULFILLED

      await inboxRepository.save(inboxMessage)
      await sagaRepository.save(sagaEntity)
      await orderRepository.save(order)

    })
  }
    async compenstate(): Promise&ltvoid&gt {
    // last step, no compensation
    }
}
</pre>

			<h2>Saga Class</h2>
			<p>
			In order to string these steps together, I created a Saga class which contains all of the aformentioned 
			steps. The class object contains an array of all steps, keeps track of the next step to be completed via an index, and 
			keeps track of which steps have completed so far in another array. It might be cleaner to implement this as a linked list
			to better represent an ordering of the steps, although I'm not convinced it is critically important.
			The saga additionally keeps information about the order that it is coordinating, 
			such as orderId, productId, and quantity
			</p>

<pre class='prettyprint lang-typescript'>
export class OrderSaga {

	public steps: SagaStepInterface&ltOrderSagaStepData, OrderSagaStepData&gt[]
	public completed: SagaStepInterface&ltOrderSagaStepData, OrderSagaStepData&gt[]
	public index: number
	public orderId: UUID
	public productId: number
	public quantity: number

	constructor(orderId: UUID, productId: number, quantity: number) {
		this.orderId = orderId
		this.productId = productId
		this.quantity = quantity
		this.index = 0
		this.steps = []
		this.completed = []
	}

	async invokeNext(messageId?: UUID) {
		if (this.index == this.steps.length) {
			console.log('No more steps left, saga is completed')
			return
		}
		await this.steps[this.index].invoke({messageId, orderId: this.orderId, productId: this.productId, quantity: this.quantity, orderSaga: this})
		this.completed.push(this.steps[this.index])
		this.index+=1
	}

	async compensate(messageId?: UUID) {
		console.log(`compensating saga with orderId: ${this.orderId}`)
		const stepsToRollback = this.completed.slice(0, -1).reverse()
		for (const step of stepsToRollback) {
			await step.compenstate({messageId, orderId: this.orderId, productId: this.productId, quantity: this.quantity, orderSaga: this})
		}
	}
}
			</pre>
				<h3>Builder Pattern</h3>
				In order to easily create ordersagas, I've created a builder pattern to add steps incrementally 

<pre class='prettyprint lang-typescript'>
export class OrderSagaBuilder {

	private orderSaga: OrderSaga

	constructor(orderId: UUID, productId: number, quantity: number) {
		this.orderSaga = new OrderSaga(orderId, productId, quantity)
	}

	addStep(step: SagaStepInterface&ltOrderSagaStepData, OrderSagaStepData&gt) {
		this.orderSaga.steps.push(step)
		return this
	}

	setStep(lastCompletedStep: STEP) {
		if (!lastCompletedStep) return
		for (const step of this.orderSaga.steps) {
			if (step.step === lastCompletedStep) {
				this.orderSaga.completed.push(step)
				this.orderSaga.index+=1
				return
			}
			this.orderSaga.completed.push(step)
			this.orderSaga.index+=1
		}
	}

	build() {
		return this.orderSaga
	}
}
				</pre>

				<h3>Factory Pattern</h3>

				I use the builder pattern within my factor pattern. The factory pattern becomes very useful
				when we have to recreate the sagas from the database during the even of an orchestrator crash.
				We will see this later

<pre class='prettyprint lang-typescript'>
export class OrderSagaFactory {

	constructor(private datasource: DataSource) {}

	createSaga(orderId: UUID, productId: number, quantity: number, lastCompletedStep?: STEP) {
		const builder = new OrderSagaBuilder(orderId, productId, quantity)

		builder.addStep(new CreateOrderStep(this.datasource))
		.addStep(new RemoveInventoryStep(this.datasource))
		.addStep(new ShipOrderStep(this.datasource))
		.addStep(new FinalizeOrderStep(this.datasource))

		builder.setStep(lastCompletedStep)

		return builder.build()
	}
}
</pre>
			<h2>Saga Orchestrator</h2>
			The orchestrator is the class which manages the lifecycle of all sagas ongoing in the program.
			For each order there would be an instance of the saga class, and the orchestrator keeps track 
			of all of these in a map from orderId to saga. It then is able to call the invoke or compensate 
			actions of a respective saga based on an orderId

<pre class='prettyprint lang-typescript'>
export class OrderSagaOrchestrator {

	private sagas = new Map&ltUUID, OrderSaga&gt();

	constructor(private orderSagaFactory: OrderSagaFactory, private datasource: DataSource) {}

	async newSaga(productId: number, quantity: number) {
		const orderId = randomUUID()
		const saga = this.orderSagaFactory.createSaga(orderId, productId, quantity)
		this.sagas.set(orderId, saga)
		await this.invokeNext(orderId)
	}

	async invokeNext(orderId: UUID, messageId?: UUID) {
		const saga = this.sagas.get(orderId)
		if (!saga) {
			console.log(`No saga with orderId ${orderId} found`)
			return
		}
		await saga.invokeNext(messageId)
	}

	async compensateSaga(orderId: UUID, messageId?: UUID) {
		const saga = this.sagas.get(orderId)
		await saga.compensate(messageId)
	}

	async restoreFromDb() {
		const sagaRepository = this.datasource.getRepository(OrderSagaEntity)
		const sagaEntities = await sagaRepository.find()
		const sagas = sagaEntities.filter(entity =&gt entity.lastCompletedStep !== STEP.FINALIZE_ORDER && entity.lastCompletedStep !== STEP.COMPENSATE).map(entity =&gt {
			console.log(`restoring saga with order id ${entity.orderId}. Last completed step was ${entity.lastCompletedStep}`)
			return this.orderSagaFactory.createSaga(
				entity.orderId, 
				entity.productId, 
				entity.quantity,
				entity.lastCompletedStep
			)
		})
		sagas.forEach(saga =&gt {
			this.sagas.set(saga.orderId, saga)
		})
	}
}
			</pre>
				<h3>Recover sagas after crash</h3>
				The most interesting piece of this class is the restoreFromDb method. This utilizes the order saga factory 
				and typeorm ordersagaEntity repository in order to fetch all sagas that have been persisted to the database,
				and recreate them and put them in the right step. If any sagas have completed, they are not instantiated 
				again. After a while, sagas within this set that are completed are also cleaned up

			<h2>Http Server</h2>

			There is a super simple http server built using express to accept incoming requests to the order service, and kick
			off a new sgaa for the order
<pre class='prettyprint lang-typescript'>
export class Server {
	private app: express.Express

	constructor(private port: number, private orderSagaOrchestrator: OrderSagaOrchestrator) {}

	init() {
		this.app = express()
		this.app.use(bodyParser.json())
		this.registerRoute('/', HTTP_METHOD.POST, this.placeOrder)
		this.listen()
	}

	private placeOrder = async (req: express.Request, res: express.Response) => {
		const {productId, quantity}: {productId: number, quantity: number} = req.body
		if (!productId || !quantity) {
			res.status(400).send('No product or quantity')
		}
		await this.orderSagaOrchestrator.newSaga(productId, quantity)
		res.send()
	}

	private registerRoute = (path: string, method: HTTP_METHOD, func: (req: express.Request, res: express.Response) => any) => {
		switch(method) {
			case HTTP_METHOD.GET: 
				this.app.get(path, func)
				break;
			case HTTP_METHOD.POST: 
				this.app.post(path, func)
				break;
			default: 
				throw new Error('not supported')
		}
	}

	private listen = () =&gt {
		this.app.listen(this.port, () =&gt {
		  console.log(`Example app listening on port ${this.port}`)
		})
	}
}
			</pre>

			<h2>RabbitMQ</h2>
			The rabbitMQ service is what listens to the channels and routes messages back to the order saga orchestrator. There is 
			also a critical method called pollOutbox, which is used to send the outbox messages that have been persisted to the database
			to the downstream services
<pre class='prettyprint lang-typescript'>

export class RabbitMQService {

	private channel: amqplib.Channel

	constructor(private datasource: DataSource, private orderSagaOrchestrator: OrderSagaOrchestrator) {
	}

	async init() {
	  const connection = await amqplib.connect({
		  username: process.env.RABBITMQ_USER,
		  password: process.env.RABBITMQ_PASSWORD
	  });
	  const channel = await connection.createChannel();
	  this.channel = channel;

	  for (const queue of Object.values(OUTBOX_MESSAGE_TYPE)) {
		await channel.assertQueue(queue)
	  }

	  for (const queue of Object.values(INBOX_MESSAGE_TYPE)) {
		await channel.assertQueue(queue)
		this.listenForMessage(queue)
	  }
		this.pollOutbox()
	}

	listenForMessage = async (queue: INBOX_MESSAGE_TYPE) => {
		await this.channel.consume(queue, async (msg) => {
			if (msg !== null) {
				const message: ResponseMessage = JSON.parse(msg.content.toString())
				console.log(`Received message with orderId ${message.orderId} and status ${message.success}`);
				if (message.success) {
					await this.orderSagaOrchestrator.invokeNext(message.orderId, message.id)
				} else {
					await this.orderSagaOrchestrator.compensateSaga(message.orderId)
				}
				this.channel.ack(msg)
			}
		})
	}

	pollOutbox = () => {
		const outboxRepository = this.datasource.getRepository(OutboxMessage)
		setInterval(async () => {
			const outboxMessages = await outboxRepository.find()
			outboxMessages.forEach(async outboxMessage => {
				const json = outboxMessage.toJson();
				const buffer = Buffer.from(JSON.stringify(json))
				console.log(`sending outbox message to ${outboxMessage.messageType} queue`)
				this.channel.sendToQueue(outboxMessage.messageType, buffer)
				await outboxRepository.remove(outboxMessage)
			})
		}, 5000)
	}

}
			</pre>

			<h3>orderId on messages</h3>
			On each message between services, there is an OrderId. This allows the rabbitMQ service to pass it to the saga orchestrator
			and then the saga orchestrator can fetch the saga that is corresponding to that message. 


        </article>
    </main>
    <footer>
        <span class="date">SWE @ Sentinel Group</span>
    </footer>
</body>
</html>
