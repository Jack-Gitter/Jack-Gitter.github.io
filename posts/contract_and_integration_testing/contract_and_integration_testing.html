<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Contract and Integration Testing with Prism and TestContainers</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Contract and Integration Testing with Prism and TestContainers</h1>
    </header>
    <main>
        <article>
            <h1>Integration Testing</h1>
            <p class="date">April 29, 2025</p>
            <p>
               In order to effectively test an application, it's crucial to konw that it properly interacts with other 
               services and databases in order to achieve its goal without errors. In a world where all systems are not owned by 
               a single team, or changes are occuring fast and frequently, it might be difficult to keep all the systems up to date. 
               Its important to have systems in place that ensure any code that relies on another system is integrated properly, and if not 
               it should be detected as fast as possible. This can be said for anything, whether it be an HTTP request to another microservice, 
               or a call to a database. If the microservice changes its endpoints, or the DBMS itself changes, it is important to know whether 
               the application can handle these changes, or if intervention is needed. Integeration testing allows for this process to be automated, 
               and ensure proper communication between an application and its dependencies. 
            </p>
            <h1>Test Containers</h1>
            <p>
                Using docker test containers, it is very easy to spin up an instance of an applications dependencies for testing. There are many 
                SDKs for all sorts of different languages, making the creation of a database for testing purposes a trivial activity. In order to make 
                sure that the system you are developing interacts with another properly, test containers can be used to manage an instance of another
                application for the duration of the test. It will spin up the dependency, allow for the tests to make real network connections to 
                the resources, run real network requests, and recieve real responses. With this, no mocking is necessary, and the integration between the 
                two system is what is being tested. In the folliwng examples, I'll use a postgres docker testcontainer in order to test the intergration of a 
                simple microservice with the database.
            </p>
            <h1>Homes Service</h1>
            <p>
                For the duration of the article, I'll be referncing code from a very basic NestJS project that I've developed. The sole purpose of this 
                service is to manage homes for an application. This service simply can fetch all the homes that are currently stored in the database,
                fetch homes based on specific criteria, or "reserve" a home, which really doesn't do anything in this case. The service is kept 
                brutally simple to focus on the testing aspect.
                

        <span>
@Controller('homes')
export class HomesController {
  constructor(private homesService: HomesService) {}

  @Get()
  public async getHomes() {
    return await this.homesService.getHomes();
  }

  @Get('/:city/:street/:zip')
  public async findHome(@Param() findHomeDto: FindHomeDTO) {
    return await this.homesService.findHome(
      findHomeDto.city,
      findHomeDto.street,
      findHomeDto.zip,
    );
  }

  @Post('/reservation/:city/:street/:zip')
  public async reserveHome(@Param() reserveHomeDto: ReserveHomeDTO) {
    return await this.homesService.reserveHome(
      reserveHomeDto.city,
      reserveHomeDto.street,
      reserveHomeDto.zip,
    );
  }
}
        </span>

        <span>
@Injectable()
export class HomesService {
  constructor(
    @InjectRepository(Home) private homesRepository: Repository<Home>,
  ) {}

  public async getHomes() {
    return await this.homesRepository.find();
  }

  public async findHome(city: string, street: string, zip: string) {
    const home = await this.homesRepository.findOneBy({
      street,
      city,
      zip,
    });
    if (home) {
      return home;
    } else {
      throw new NotFoundException('Home does not exist');
    }
  }

  public async reserveHome(city: string, street: string, zip: string) {
    const home = await this.homesRepository.findOneBy({
      street,
      city,
      zip,
    });
    if (!home) {
      throw new NotFoundException('Home does not exist');
    }
  }
}
        </span>

            </p>
            <h1>Databases and Running Migrations on TestContainers</h1>
            <p>
            </p>
            <h1>Seeding TestContainers</h1>
            <p>
            </p>
            <h1>Contract Testing</h1>
            <p>
            </p>
            <h1>OpenAPI Specification</h1>
            <p>
            </p>
            <h1>Profiles Service</h1>
            <p>
            </p>
            <h1>Contract Generation</h1>
            <p>
            </p>
            <h1>HTTP Server with Prism and OpenAPI</h1>
            <p>
            </p>
            <h1>Static vs Dynamic Responses with Prism</h1>
            <p>
            </p>
            <h1>Prism docker container</h1>
            <p>
            </p>
            <h1>Keeping Contracts up to Date</h1>
            <p>
            </p>
        </article>
    </main>
    <footer>
        <span class="date">JSWE at Sentinel Group</span>
    </footer>
</body>
</html>
