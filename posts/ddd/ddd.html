<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Domain Driven Design</title>
    <link rel="stylesheet" href="../../styles.css">
    <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script> </head>
<body>
    <header>
        <h1>Domain Driven Design</h1>
    </header>
    <main>
        <article>
            <h1>Benefits and Overview of DDD</h1>
            <p class="date">April 28, 2025</p>

            <p>
                Domain Driven Design is an approach to software design that puts a very emphasis on creating a model in code which is as close to 
                the real business as possible. At its core, it's all about the the data model. Things such as the database design come second, and 
                are typically implemented with an ORM. There are many guidelines to follow when developing using DDD, and the process starts well before 
                any code is written. The DDD philosophy begins by introducing a ubiquitous language which allows for seamlessly communicate 
                between business experts and software engineers about the domain.
            </p>

            <h2>Ubiquitous language</h2>

            <p>
                Trying to reason about code with business experts is often difficult. Code and logic typically has to be "translated" from 
                the terms used in the software to the terms business experts use, and vice versa. With translation comes loss of information, 
                and loss of information causes errors in implementation. A ubiquitous language eliminates these concerns by defining a set of terms 
                used to describe the business so domain experts and developers can communicate flawlessly. Typically, terms from the business are utilized 
                and integrated into the ubiquitous language when possible, to have the model remain as accurate as possible.
            </p>

            <h2>Value Objects</h2>
            <p>
                In DDD, the smallest unit of building block is typically a Value Object. Value Objects are pieces of a model which obtain value soley 
                on the content of their components. To put it more concretely, a JSON Value Object which has the same exact fields as another JSON 
                Value Object are equal. They are typically created as immutable, as changing one value of the value object would completly change the object. 
                In the circumstance where a Value Object is expected to change, it is preffered to create an entire new object. A good example of a 
                Value Object is a name.

                <pre class='prettyprint lang-typescript'> export type Name = { first: string; middle?: string; last: string; } </pre>

                A name might include first, middle, and last components. Changing any part of this name completly makes it a new name entirely. 
                </p>


            <h2>Entities</h2>

            <p>



                Entities are the next largest buliding blocks of DDD. They are the code representation of business objects, concepts, and logic. They always
                have a unique ID, typically implemented as a simple UUID. This represents their intrinsic real-life value separately from the value objects that
                are used to compose them.

                <div class='sidenote'>
                    There is often confusion between entities and value objects when first learning DDD. The difference is best explained via an example.
                    Lets take the example of a Person entity which has a name value object field. A person can change their name (swap it out for another
                    value object), but the person themselves is still intrinsically the same person they previously were. 
                </div>

                Most of the time, entities are implemented as classes in an OOP language. Mostly all business logic should reside as methods within an entity.
                Entities should have no external dependencies outside of the domain layer, only focused on implementing business logic as accurately as 
                possible

                <div class='sidenote'>
                    There exists a notion betwen "thick" and "thin" domain models. A thick model is when business logic is implemented on 
                    an entity as methods, a thin model's business logic is implemented in services which wrap entities. DDD heavily 
                    favors thick domain models, as the logic is isolated, reusable, and can tested without any dependencies. When developing a thin model,
                    logic is not reusable between services, and is much harder to test. 
                    Services frequently have dependencies on repositories, and this causes the need to mock datbase connections simply to test domain logic.
                </div>

                <pre class='prettyprint lang-typescript'>export class Reservation {

    @PrimaryGeneratedColumn('uuid')
    public id: UUID

    @ManyToOne(() => Flight, (flight) => flight.reservations, {orphanedRowAction: 'delete'})
    public flight: UUID

    @Column(() => SeatPosition)
    public seatPosition: SeatPosition

    @Column('uuid')
    public personId: UUID

    private constructor(seatPosition: SeatPosition, personId: UUID, flight: UUID) {
        this.seatPosition = seatPosition
        this.personId = personId
        this.flight = flight
    }

    static CreateReservation(seatPosition: SeatPosition, personId: UUID, flight: UUID): Reservation {
        return new Reservation(seatPosition, personId, flight)
    }
}

</pre>

            The above entity represents a reservation for a flight. It is comprised of a Value Object called SeatPosition which contains seat position information, 
            and also has foreign references to the person entity who made the reservation and the flight entity to which the reservation is associated to. 
            With a more complete understanding of Entities and Value Objects, it can be seen that the relationship between VO and Entities can be described
            as so: value objects, such as SeatPosition, make up a subset of the columns in a database entry. The entire record is the Entity itself. If a reservation
            gets upgraded to first class, the seat position might change, but the reservation still holds the same intrinsic value it previously did. 
            Thinking database-first is against the DDD methodology, but it is simply another way to distinguish VO and entities.
            </p>

            <h2>Aggregate Roots</h2>
            <p>
                An aggregate is a collection of entities that typically belongs together in a database transaction. An Aggregate root is the entity which
                "owns" the other entities in any given aggregate. An agggregate root represents a consisstency boundary. If two or more entities
                cannot be out of sync for any period of time, they must be organized together in an aggregate. Because of this, all work done to an 
                aggregate must be done via the interface for the aggregate root, so that it can ensure business invariants are satisfied. 
                An aggregate root can be thought of as an orchestrator for the sub-entities that it contains. It 
                has a complete view of all its objects, so it can ensure that no invariants are ever violated when performing business logic.

<pre class='prettyprint lang-typescript'>export class Flight {

    @PrimaryGeneratedColumn('uuid')
    public id: UUID

    @Column({type: 'enum', enum: FLIGHT_STATUS, default: FLIGHT_STATUS.ON_TIME})
    public status: FLIGHT_STATUS

    @OneToOne(() => FlightSchedule, (flightSchedule) => flightSchedule.flight, 
    { cascade: true, onDelete: 'NO ACTION', nullable: true, createForeignKeyConstraints: false })
    @JoinColumn()
    public schedule: UUID

    @OneToMany(() => Reservation, (reservation) => 
    reservation.flight, { cascade: true, onDelete: 'CASCADE', orphanedRowAction: 'delete' })
    public reservations: Array<Reservation>

    @OneToMany(() => Seat, (seat) => 
    seat.flight, { cascade: true, onDelete: 'CASCADE', orphanedRowAction: 'delete' })
    public seats: Array<Seat>

    constructor(id: UUID, seats: Array<Seat>) {
        this.id = id
        this.seats = seats
        this.status = FLIGHT_STATUS.ON_TIME
    }

    public makeReservation(seatPosition: SeatPosition, personId: UUID) {

        if (!this.reservations) {
            this.reservations = new Array<Reservation>()
        }

        const seat = this.seats.find((seat) => seat.position.equals(seatPosition))

        if (!seat) {
            throw new BadRequestException(
            `No seat found with the position ${seatPosition} on the flight ${this.id}`
            )
        }

        const existingReservation = this.reservations.find((reservation) => 
            reservation.seatPosition.equals(seatPosition))

        if (existingReservation) {
            throw new BadRequestException(
            `Reservation already exists for seat ${seatPosition} on the flight ${this.id}`
            )
        }

        const reservation = Reservation.CreateReservation(seatPosition, personId, this.id)

        this.reservations.push(reservation)
    }

    public cancelReservation(seatPosition: SeatPosition, personId: UUID) {

        if (!this.reservations) {
            throw new BadRequestException(`No reservations exist for this flight!`)
        }

        const seat = this.seats.find((seat) => seat.position.equals(seatPosition))

        if (!seat) {
            throw new BadRequestException(
            `No seat found with the position ${seatPosition} on the flight ${this.id}`
            )
        }

        const existingReservation = this.reservations.find((reservation) => 
            reservation.seatPosition.equals(seatPosition))

        if (!existingReservation) {
            throw new BadRequestException(
            `No existing reservation with that information exists`
            )
        }

        this.reservations = this.reservations.filter((reservation) => 
            { reservation.id !== existingReservation.id })

    }

    public cancelReservationsByPerson(personId: UUID) {

        if (!this.reservations) {
            throw new BadRequestException(`No reservations exist for this flight!`)
        }

        const existingReservations = this.reservations.filter((reservation) => 
            reservation.personId === personId)

        if (existingReservations.length === 0) {
            throw new BadRequestException(
            `No existing reservation with that information exists`
            )
        }

        this.reservations = this.reservations.filter((reservation) => 
            reservation.personId !== personId)

    }

    public setSchedule(schedule: UUID) {
        this.schedule = schedule
    }

    public removeSchedule() {
        this.schedule = null
    }
} </pre> 

            The above example represents the aggregate root for a flight in an application that helps people to book flights on airlines.
            The business has given us an invariant: at no time must a single seat ever be booked by more than one person at a time. With this, we 
            know that the Seat and Reservation entities must be encapsulated within the Flight aggregate. This gives the Flight aggregate root the ability 
            to know the state of all seats and reservations, and enforce the the required invariant. The implementation can be seen in the MakeReservation method, 
            where we ensure that no other existing reservation currently exists for the given flight before allowing the user to book that seat.
            </p>

            <p>
            Taking a close look at the aggregate, we can see that there is not only encapsulation, but also another form of a relationship: a reference. 
            The Flight aggregat root has a reference to the schedule that is associated with the current flight. For our business, there are no totalities 
            for the relationship between a flight schedule and a flight. Because of this, the flight schedule does not need to be encapsulated in the Flight 
            aggregate, but rather can be its own Entity. Communication between the two can occur via domain events, reaching an eventually consistent state. 
            At a later point if needed, this object can be easily refactored into a separate service since no database transactions need to occur between 
            the Flight and the corresponding schedule.
            </p>

            <h2>Factory Pattern</h2>

            <p>
            The factory pattern is heavily used in DDD to construct complex aggregates, and enforce invariants while doing so. In the case of a Flight, there 
            might some rules that exist for a flight to be created. Some of these could include commercial flights containing lots of cheap seats,
            and private flights having less quantity but higher priced seats. Extracting this functionality from the Flight aggregate itself keeps the 
            Flight aggregate and FlightFactory classes cleaner, and helps to enforce the single responsibility principal. Additionally testing the creation of
            the aggregate can now be separated from the implementation.

<pre class='prettyprint lang-typescript'>export class FlightFactory {
    public createFlight(flightType: FLIGHT_TYPE): Flight {
        let seats: Array<Seat>
        const flightId = randomUUID()
        switch (flightType) {
            case FLIGHT_TYPE.Commercial: 
                seats = this.generateSeats(
                    flightId, flightType, new Price(
                        USD, 
                        BASE_COMMERCIAL_FLIGHT_PRICE_UNITS, 
                        BASE_COMMERCIAL_FLIGHT_PRICE_SUB_UNITS)
                    )
                return new Flight(flightId, seats)
            case FLIGHT_TYPE.Private:
                seats = this.generateSeats(
                    flightId, 
                    flightType, 
                    new Price(
                        USD, 
                        BASE_PRIVATE_FLIGHT_SUB_UNITS, 
                        BASE_PRIVATE_FLIGHT_SUB_UNITS)
                    )
                return new Flight(flightId, seats)
            default: 
                throw new BadRequestException('Unknown Flight Type')
        }
    }

    private generateSeats(flightId: UUID, flightType: FLIGHT_TYPE, basePrice: Price): Array<Seat> {
        switch (flightType) {
            case FLIGHT_TYPE.Commercial: 
                return this.seatAlgorithm(flightId, COMMERCIAL_FLIGHT_ROW_COUNT, basePrice)
            case FLIGHT_TYPE.Private:
                return this.seatAlgorithm(flightId, PRIVATE_FLIGHT_ROW_COUNT, basePrice)
            default: 
                throw new BadRequestException('Unknown Flight Type')
        }
    }

    private seatAlgorithm(flightId: UUID, flightRowCount: number, basePrice: Price): Array<Seat> {
        const flightSeats: Array<Seat> = new Array<Seat>()
        for (const seatRow of [...Array(flightRowCount).keys()]) {
            for (const seatCol of Object.values(SEAT_COLUMN)) {
                const seatPosition = new SeatPosition(seatRow, seatCol)
                const newUnits = 
                    basePrice.getUnitsCopy() + Math.floor(Math.random() * SEAT_VOLITILITY)
                const seatPrice = 
                    new Price(basePrice.getCurrencyCopy(), newUnits, basePrice.getSubUnitsCopy())
                const seat = 
                    Seat.CreateSeat(flightId, seatPosition, seatPrice)
                flightSeats.push(seat)
            }
        }
        return flightSeats
    }
}
</pre>
            Here, the complex logic of generating seats depending on what type of flight is created is localized only to this class itself. It does not clutter
            the Flight entity isleft, nor is it relevant to Flight functionality. 
            </p>


            <h2>Repository Pattern</h2>

            <p>
                Repositories are classes on the interface layer responsible with interfacing with the underlying database to fetch aggregate roots. 
                There should be one repository per aggregate root, and repositories should only ever load aggregate roots into memory. This is because
                the aggregate-root enforces the invariants amongst sub-entities, and fetching a sub-entity directly and modifying it could bypass
                an invariant check that would have otherwise been performed by the aggregate root. Many ORMs implement the repository pattern, so that 
                developers can truly take a code-first approach if desired. A typical workflow is that an aggregate root is loaded from the datbase via a 
                repository for that specific aggregate, they are operated on, and then saved back into the database. 

<pre class='prettyprint lang-typescript'>export class AddSegmentService {

    constructor(
        @InjectRepository(FlightSchedule) private flightScheduleRepository: Repository<FlightSchedule>
    ) {}

    public async addSegment(
        scheduleId: UUID, 
        toName: string, 
        toLongitude: number, 
        toLatitude: number, 
        fromName: string, 
        fromLongitude: number, 
        fromLatitude: number, 
        start: Date, 
        end: Date
    ) {
        await this.flightScheduleRepository.manager.transaction(async (entityManager) => {
            const to = new Location(toName, toLongitude, toLatitude)
            const from = new Location(fromName, fromLongitude, fromLatitude)
            const segment = new Segment(to, from, start, end)
            const flightScheduleRepository = entityManager.getRepository(FlightSchedule)
            
            const flightSchedule = await flightScheduleRepository.findOne({
                relations: ['segments'],
                where: {id: scheduleId}
            })

            if (!flightSchedule) {
                throw new BadRequestException(`No schedule with id ${scheduleId}`)
            }

            flightSchedule.addSegment(segment)

            return await this.flightScheduleRepository.save(flightSchedule)
        })
    }

}
                </pre>

                In the above example, we add a segment to a flightSchedule by loading it into memory, operating on it via methods, and then saving it back
                to the database.

                <div class='sidenote'>
                    When performing in-memory manipulation of an object and then saving it back to the database, there must be some 
                    method in place to avoid data races which can be caused by other threads or instances of the application loading the 
                    same aggregate, performing a conflicting operation, and then saving it back to the database at the same time.
                    The two most prominant ways to prevent a data race is to either use database pessimistic or optimistic locking. 
                    Both implementations prevent the described undesired behavior, although pessimistic locking is better for applications
                    which are expected to have more conflicts, and optimistic locking is better for instances where the application is
                    not expected to have such problems often.
                </div>
            </p>



            <h2>Domain Services</h2>
            <p>
                Domain services are used to implement domain logic between two entities, when that logic does not make sense to fall within a single
                entity itself. Typically, domain entities should not have dependencies on anything outside of the domain layer. They are passed in
                one or more aggregate roots, and implement pure business logic. One good example of this is a social media platform where users can 
                follow eachother. It does not make sense to have the business logic implemented on a single user object, since it spans multiple users at once.
                Rather, it would make the most sense to load both users into memory, pass them to a domain service, and allow the domain service to call
                methods such as updateFollowers() and updateFollowing() on the respective Entities.
            </p>


            <h2>Application Services</h2>

            <p>
                Applications are the orchestrators of different business functionality. They are responsible for loading entities from the database,
                making the calls to business logic, saving entities back to the database, and making any other external calls the business logic needs.
                Here is an example of a 
                

<pre class='prettyprint lang-typescript'>export class CreateReservationService {

    public constructor(
        @InjectDataSource() private dataSource: DataSource,
        @Inject('RMQ_CLIENT') private rmqClient: ClientProxy
    ) {}

    public async createReservation(
        flightId: UUID, 
        personId: UUID, 
        seatRow: number, 
        seatCol: SEAT_COLUMN
    ) {

        await this.dataSource.transaction(async (entityManager) => {

            const flightRepository = entityManager.getRepository(Flight)

            const flight = await entityManager
            .getRepository(Flight)
            .createQueryBuilder('flight')
            .innerJoinAndSelect('flight.seats', 'seats')
            .where('flight.id = :flightId', {flightId})
            .setLock('pessimistic_write')
            .getOne()

            if (!flight) {
                throw new NotFoundException(`Cannot find flight with id ${flightId}`)
            }

            const seatPosition = new SeatPosition(seatRow, seatCol)

            flight.makeReservation(seatPosition, personId)

            await flightRepository.save(flight)

            this.rmqClient.emit('PersonExistsCheck', personId)

        })
    }
}</pre>
            </p>

            <h2>Domain events</h2>

            <p>
                Domain events are used to communicate between aggregate roots. Because two aggregate roots do not need to be immediately consistent, 
                they can be decoupled and communicate via a message broker or other asynchronous means to achieve a common goal via eventual consistency.
                Using this model allows for refactoring aggregate roots into separate microservice, since an eventually consistent model is already 
                implemented.
            </p>


            <h2>Bounded Contexts and Microservices</h2>
            <p>
                Different sections of business functionality are typically represented by different bounded contexts. For example, in the example of a 
                flight reservation application, there might be one bounded context which handles all the information surrounding booking flights, and another
                bounded context which is responsible for keeping track of user accounts and related information. Each bounded context in a microservice 
                architecture is represented by a new microservice. Information in a bounded context's data model should be only relevant to the context 
                of said bounded context. For example, in the bounded context which handles flight reservations, a flight is composed of seats, 
                reservations, segments, etc. The reservation context needs all of this information to reason about the availability of flights and validity of 
                attempted reservations. In the user acounts bounded context, a flight is simply a UUID, pointing to an entity in the reservation context.
                The user context might only care about how many flights a user has taken, to set the user's status to "Premium" if they have flown over 
                1000 times. Because of the separation of conerns, messages between bounded contexts should be thin, meaning that they contain little information.
                This is because information is not duplicated accross microservies, so instead of sending data from one application to another, more event-style
                messages are sent to kick off a process, typically with the UUID of a specific entity in the calling bounded context. 
            </p>

            <h2>CQRS</h2>

            <p>
                CQRS stands for Command query response separation, and is a methodology often paired with DDD. Since SELECT queries do not effect the database
                in any way, there are no invariants or business logic to uphold. With this being the case, the model for updating records and fetching data 
                is often naturally different. With CQRS, aggregates can be used to inforce business rules, and separate models which do not relate to the 
                aggregate models in any way can be created to load and display information to users. Utilizing aggregates to load and return data is 
                not only overly complex, but also will likely negatively impact the accuracy of the model in ways which are unnecssary.
            </p>

            <h2>Code</h2>
            <p>
            For a full code example, please refer to the following <a href='https://github.com/Jack-Gitter/airplane-application'>Repo Link</a>
            </p>
        </article>
    </main>
    <footer>
        <span class="date">JSWE at Sentinel Group</span>
    </footer>
</body>
</html>
