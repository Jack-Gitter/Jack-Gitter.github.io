<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Domain Driven Design</title>
    <link rel="stylesheet" href="../../styles.css">
    <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
</head>
<body>
    <header>
        <h1>Domain Driven Design</h1>
    </header>
    <main>
        <article>
            <h1>Benefits and Overview of DDD</h1>
            <p class="date">April 25, 2025</p>

            <p>
                Domain Driven Design is an approach to software design that puts a very emphasis on creating a model in code which is as close to 
                the real business as possible. At its core, it's all about the the data model. Things such as the database design come second, and 
                are typically implemented with an ORM. There are many guidelines to follow when developing using DDD, and it starts well before 
                any code is written. The DDD philosophy requires use of a ubiquitous language to seamlessly communicate with business experts 
                about the business, and easily reason about the validity of code.
            </p>

            <h2>Ubiquitous language</h2>

            <p>
                Trying to reason about code with business experts is often difficult. Code and logic typically has to be "translated" from 
                the terms used in the software to the terms business experts use, and vice versa. With translation comes loss of information, 
                and loss of information causes errors in implementation. Ubiquitous language eliminates these concerns by defining a set of terms 
                used to describe the business so domain experts and developers can communicate flawlessly. Typically, terms from the business are utilized 
                and integrated into the ubiquitous language when possible, to have the model stay as close to the real life as possible.
            </p>

            <h2>Value Objects</h2>
            <p>
                In DDD, the smallest unit of building block is typically a Value Object. Value Objects are pieces of a model that gain value soley 
                based on the content of their components. To put it more concretely, a JSON Value Object who has the same exact fields as another JSON 
                Value Object are equal. They are typically created as immutable, since changing one value of the value object would completly change the object. 
                It is preffered to create another value object entirely instead of changing the field of a value object. A good example of a value object is a name.

                <pre class='prettyprint lang-typescript'> export type Name = { first: string; middle?: string; last: string; } </pre>

                A name might have first, middle, and last fields. Changing any part of this name completly makes it a new name. 
                Lets consider a person who has a name. The person can change their name, but the person themselves is still intrinsically the same person
                they previously were. In this instance, the name is a Value Object, and the person is an Entity.
            </p>


            <h2>Entities</h2>

            <p>
                Entities are the next largest buliding blocks of DDD. They are the code representation of business objects, concepts, and logic. They always
                have a unique ID, typically implemented as a simple UUID. This represents their intrinsic real-life value separately from the value objects that
                are used to compose them.

                Most of the time, entities are implemented as classes in an OOP language. Mostly all business logic should reside within an entity,
                so it can be re-used across services. 
                <div class='side-note'>
                    there is a notion betwen thick vs thin domain models, meaning thick is when business logic is implemented on 
                    entities inthe form of methods, and thin meaning that logic is implemented in teh services that utilize entiies. When using thin domain models,
                    logic is not re-usable, and much harder to test. Since its in a service, it might involve mocking datbase connections, etc. Keeping it in the 
                     seIhmmdomain model allows it to be isolated, and tested without any dependencies
                </div>

                 <div>
                    Example of a domain object for an Airplane
                 </div>
                 <div>
                    Example of another domain object (to use below)
                 </div>

                ease of testing. entities do not deped on anything else, making business logic extremely easy to test. no mocking database connections, etc
            </p>

            <h2>Aggregate Roots</h2>
            <p>
                an aggregate root is a collection of entities that typically belongs together in a database transaction. DDD relies heavily on 
                doamin events and eventual consistency. An agggregate root represents a consisstency boundary. If two or more things
                cannot by any means be out of sync, they need to be together in an aggregate. messages to one aggregate to another
                must go through the aggregate root, either you could end up with inconsistencies as the job of an aggregate is also to enforce 
                invariants: things that must always be true according to business logic, and can never afford to be false. it can be thought of 
                as an entity "manager" as the root has a view on all of the entities within the aggregate. It can see the state of them, and because it has 
                the context of all other entities in the aggreagte, it has the ability to make decisions.

                <div>
                    code example of an aggregate root
                </div>
            </p>

            <h2>Factory Pattern</h2>

            <p>
                used to construct complex aggregates, so that the construction of them can be tested separately from the implementation of them. 
                It makes use of the single reponsibility principal, as complex logic related to other entities may be used to construct an aggregate
            </p>

            <h2>Repository Pattern</h2>

            <p>
                repositories are classes that fetch aggregate roots from a database. They help with the translation between the flat structure of a SQL database,
                and reconstructing this data into an entity. Typically, entities are loaded from datbase via a repository, they are operated on, and then
                loaded back into the datbase. Repositories load entire aggregates.

                <div>
                    code example
                </div>

                <div class='side-note'>
                    side note: need some sort of locking, transaction, select for update, or MVCC to avoid data races -- aggregate roots!
                </div>
            </p>



            <h2>Domain Services</h2>
            <p>
                is used only to implement logic between two entities, when the business logic does not naturally fit into any entity itself

                example is two users following each other, you have a followUserService
            </p>


            <h2>Application Services</h2>

            <p>
                interacts with things outside of entities, like coordinating database, etc. It is just a coordinator of an entire feature
            </p>

            <h2>Domain events</h2>

            <p>

                for things that don't need to be immediately consistent. they are domain eventgs. domain events are messages typically delivered by queue
                so that other aggregates can be updated at a later date. This is preffered in all cases, because this model allows for refactoring 
                an aggregate into another microservice or bounded context later, since domain events means that the aggregate does not need to be included
                in a database transaction
            </p>




            <h2>Bounded Contexts and Microservices</h2>
            <p>
                Bounded context separate what entites "mean" in different contexts. for an order service, might need things like product id, 
                person who ordered, address, etc. But for inventory, we just need an ID for that entity, we don't care about who ordered, and their address. 
                Keep data as minimal as possible 
            </p>

        </article>
    </main>
    <footer>
        <span class="date">JSWE at Sentinel Group</span>
    </footer>
</body>
</html>
