<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Domain Driven Design</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Domain Driven Design</h1>
    </header>
    <main>
        <article>
            <h1>Benefits and Overview of DDD</h1>
            <p class="date">April 25, 2025</p>

            <p>
                Domain Driven Design is an approach to software design that puts a very heavy emphasis on the domain and business model. At its core, 
                DDD puts an extreme focus on accurately map the business domain into code. Its mainly concerned with the data model, and things such as 
                the database design come second. There are many guidelines to follow when developing an application in a DDD style, but before 
                jumping into code, something that is extremely important in the DDD philosophy is utilizing a ubiquitous language to communicate
                with business experts to get a better understanding about business operations, and easily communicate what the code is doing.
            </p>

            <h2>Ubiquitous language</h2>

            <p>
                When discussing existing code logic and business requirements with business experts, communication typically has to be "translated" from 
                what the terms business experts use, and what is used in the code. With translation comes loss of information, and loss of information 
                causes errors in business logic implementation, purley by misunderstanding. Ubiquitous language attempts to eliminate this translation
                by defining a set of terms used to describe business related terms so everyone can communicate on a even playing field. Typically, these
                terms are grabbed from the business when possible, as to have the code model implementation stay as close to the real life business as possible.
            </p>

            <h2>Value Objects</h2>


            <p>
                objects which are made up soley of their fileds. so two objects that have the same exact fields mean the same thing.

                <div>
                    code example of value object
                </div>

            </p>


            <h2>Entities</h2>

            <p>
                entities are the buliding blocks of DDD, They are the code representation of business objects, concepts, and logic. They always
                have a unique ID, typically impleemnted in a UUID. That is what differs them from value objects, they have intrinstic value
                outside of just their properties.


                Most of the time,
                they are implemented as classes in an OOP language. Business logic should be contained within an entity, so it can be re-used across services.
                there is a notion betwen thick vs thin domain models, meaning thick is when business logic is implemented on 
                entities inthe form of methods, and thin meaning that logic is implemented in teh services that utilize entiies. When using thin domain models,
                logic is not re-usable, and much harder to test. Since its in a service, it might involve mocking datbase connections, etc. Keeping it in the 
                 seIhmmdomain model allows it to be isolated, and tested without any dependencies

                 <div>
                    Example of a domain object for an Airplane
                 </div>
                 <div>
                    Example of another domain object (to use below)
                 </div>

                ease of testing. entities do not deped on anything else, making business logic extremely easy to test. no mocking database connections, etc
            </p>

            <h2>Aggregate Roots</h2>
            <p>
                an aggregate root is a collection of entities that typically belongs together in a database transaction. DDD relies heavily on 
                doamin events and eventual consistency. An agggregate root represents a consisstency boundary. If two or more things
                cannot by any means be out of sync, they need to be together in an aggregate. messages to one aggregate to another
                must go through the aggregate root, either you could end up with inconsistencies as the job of an aggregate is also to enforce 
                invariants: things that must always be true according to business logic, and can never afford to be false. it can be thought of 
                as an entity "manager" as the root has a view on all of the entities within the aggregate. It can see the state of them, and because it has 
                the context of all other entities in the aggreagte, it has the ability to make decisions.

                <div>
                    code example of an aggregate root
                </div>
            </p>

            <h2>Repository Pattern</h2>

            <p>
                repositories are classes that fetch aggregate roots from a database. They help with the translation between the flat structure of a SQL database,
                and reconstructing this data into an entity. Typically, entities are loaded from datbase via a repository, they are operated on, and then
                loaded back into the datbase. Repositories load entire aggregates.

                <div>
                    code example
                </div>

                <div class='side-note'>
                    side note: need some sort of locking, transaction, select for update, or MVCC to avoid data races -- aggregate roots!
                </div>
            </p>



            <h2>Domain Services</h2>
            <p>
                is used only to implement logic between two entities, when the business logic does not naturally fit into any entity itself

                example is two users following each other, you have a followUserService
            </p>


            <h2>Application Services</h2>

            <p>
                interacts with things outside of entities, like coordinating database, etc. It is just a coordinator of an entire feature
            </p>

            <h2>Domain events</h2>

            <p>

                for things that don't need to be immediately consistent. they are domain eventgs. domain events are messages typically delivered by queue
                so that other aggregates can be updated at a later date. This is preffered in all cases, because this model allows for refactoring 
                an aggregate into another microservice or bounded context later, since domain events means that the aggregate does not need to be included
                in a database transaction
            </p>




            <h2>Bounded Contexts and Microservices</h2>
            <p>
                Bounded context separate what entites "mean" in different contexts. for an order service, might need things like product id, 
                person who ordered, address, etc. But for inventory, we just need an ID for that entity, we don't care about who ordered, and their address. 
                Keep data as minimal as possible 
            </p>

        </article>
    </main>
    <footer>
        <span class="date">JSWE at Sentinel Group</span>
    </footer>
</body>
</html>
