<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SSO via SAML</title>
    <link rel="stylesheet" href="../../styles.css">
    <link rel="stylesheet" href="./saml.css">
    <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js?skin=desert"></script>
</head>
<body>
    <header>
        <h1>SSO via SAML</h1>
            <p class="date">November 23, 2025</p>
    </header>
    <main>
        <article>
            <a href="https://jack-gitter.github.io" class="top-right-button">üè†</a>
			<h2>What is SSO</h2>
				Single sign on, otherwise known as SSO, is a technique that allows an end user to sign in to a central authority once, and access an entire suite of applications without having to authenticate into each individual service. Before understanding the intricacies of SSO, there are a couple of useful terms to define

                <dl class="light-gray">
                  <dt>Identity Provider</dt>
                  <dd>The identity provider, or IDP, is the entity that handles authentication for users. Examples of popular IDPs are Okta, Auth0, and Azure</dd>

                  <dt>Service Provider</dt>
                  <dd>
					  The service provider, or SP, is the application that the user is attempting to access after authentication. Examples of popular SPs are Github,
					  Twitter, and Facebook
				  </dd>
                </dl>

			<h2>IDP Initiated SSO</h2>
			<p>
			IDP initiated SSO is one of the two main SSO flows. IDP initiated SSO entails the user initially signing into their identity provider. After authentication, 
			they are able to click into individual service providers without having to enter credentials for each


            <div class="image-description-block">
			<img src="./okta-experience.png" style="width:100%">
                <p>
				Example login screen after authenticating via Okta
                </p>
            </div>

			</p>
			<h3>High Level Walk Through</h3>
				IDP initiated SSO basics
				<ol>
					<li>
						User navigates to their IDP to login
						<div class="image-description-block">
							<img src="./okta login.png">
							<p>
							Okta login screen
							</p>
						</div>
					</li>
					<li>
						User enters authentication information and signs in, after which the IDP creates a session and gathers necessary persisted information 
					</li>
					<li>
						The IDP utilizes the persisted user information to create a message to send to the service provider
					</li>
					<li>
						When the user clicks the element to navigate into a service provider, the message the IDP created that contains the user information 
						is sent to the service provider
					</li>
					<li>
						The service providers validates the information is from the IDP (amongst other things), and creates a user session 
					</li>
				</ol>

			<h2>SP Initiated SSO</h2>
				The other main SSO flow is SP initiated SSO. 

				<h3>High Level Walk Through</h3>
				<ol>
					<li>
						User navigates to their SP of choice, for example LinkedIn
					</li>
					<li>
						The user clicks a button, such as "Sign in with Google", after which the service provider sends an authentication 
						request to the IDP 
					</li>
					<li>
						The IDP will receive the request, and redirect the user to the IDP's login screen
					</li>
					<li>
						The user signs in, and the IDP once again creates the message containing user information to send to the SP
					</li>
					<li>
						The IDP automatically sends this user information to the SP, and if accepted the user is automatically redirected to the SP's website
					</li>
					<li>
						The service provider verifies in the information is from the IDP (amongst other things), and then creates the user session
					</li>
				</ol>

			<h2>What is XML</h2>
			XML, also known as extensible markup language, 
			is the format in which messages are sent between the IDP and the SP. It is important to establish a "language" to 
			communicate with, so that messages can be parsed and processed easily
			<h2>What is SAML</h2>
			SAML, or security assertion markup language, is an open standard which utilizes XML. It is a defined schema which specifies how to write XML to transfer authentication information between service providers and identity providers
			<h3>SAML Request</h3>
			A SAML request is sent from the SP to the IDP during SP initiated SSO. It is a request for the IDP to handle user authentication. Below is an example of a SAML request

			<pre class="prettyprint lang-xml" id="xml-block">
&lt;samlp:AuthnRequest xmlns:samlp=&quot;urn:oasis:names:tc:SAML:2.0:protocol&quot;
				xmlns:saml=&quot;urn:oasis:names:tc:SAML:2.0:assertion&quot;
				ForceAuthn=&quot;false&quot;
				ID=&quot;ac3757ab77f8f87c695cbc073c3720b4e4348e518&quot;
				IssueInstant=&quot;2025-11-23T13:31:51Z&quot;
				Destination=&quot;http://localhost:3000/saml/auth&quot;
				AssertionConsumerServiceURL=&quot;https://sptest.iamshowcase.com/acs&quot;
				ProtocolBinding=&quot;urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST&quot;
				Version=&quot;2.0&quot;&gt;
&lt;saml:Issuer&gt;IAMShowcase&lt;/saml:Issuer&gt;
&lt;/samlp:AuthnRequest&gt;
			</pre>

				Furthermore, here is a breakdown of some of the important aspects of this request

				<br>
					<dl class="light-gray">
					  <dt>AuthnRequest</dt>
					  <dd>The authentication request. Acts as the wrapper for the request from the SP to the IDP. It has a couple of key attributes
					  <ul>
						<li style="margin-left: 20px">
							ID: <span>The specific AuthnRequest ID. Unique for each request. This is used in the SAML response to indicate which request the response is tied to</span>
						</li >
						<li style="margin-left: 20px">
							Issue Instant: <span>The time when the request was created</span>
						</li>
						<li style="margin-left: 20px">
							Destination: <span>Where the request is being sent to</span>
						</li>
						<l style="margin-left: 20px">
							Assertion Consumer Service URL: <span>Where the IDP should send the SAML response to</span>
						</li>
						<li style="margin-left: 20px">
							Protocol Binding: <span>The means by which the IDP should send the SAML response</span>
						</li>
					  </ul>
					  </dd>
					  <dt>Issuer</dt>
					  <dd>The creator of the AuthnRequest</dd>
					</dl>

				These, by no means, are the only possible fields in a SAML request. There are many more included in the specification. Microsoft has a decent overview in their
				<a href="https://learn.microsoft.com/en-us/entra/identity-platform/single-sign-on-saml-protocol#authnrequest">documentation</a>

			<h3>SAML Response</h3>
			A SAML response is a crucial part of both the IDP initiated and SP initiated SSO flows. This is the message containing proof of the user authentication, along with user information. It is sent from the IDP to the SP. Below is an example of a rudimentary SAML response

			<pre class="prettyprint lang-xml" id="xml-block">
&lt;samlp:Response
    xmlns:samlp=&quot;urn:oasis:names:tc:SAML:2.0:protocol&quot;
    xmlns:saml=&quot;urn:oasis:names:tc:SAML:2.0:assertion&quot;
    ID=&quot;_0e266799-35e6-4131-85b3-d049d6097536&quot;
    Version=&quot;2.0&quot;
    IssueInstant=&quot;2025-11-22T19:06:04.594Z&quot;
    Destination=&quot;https://sptest.iamshowcase.com/acs&quot;
    InResponseTo=&quot;&quot;&gt;
  &lt;saml:Issuer&gt;https://test-saml.com&lt;/saml:Issuer&gt;
  &lt;samlp:Status&gt;
    &lt;samlp:StatusCode Value=&quot;urn:oasis:names:tc:SAML:2.0:status:Success&quot; /&gt;
  &lt;/samlp:Status&gt;
  &lt;saml:Assertion
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;
      xmlns:saml=&quot;urn:oasis:names:tc:SAML:2.0:assertion&quot;
      ID=&quot;_8dea871c-d9a2-4928-8219-2bad6cc9a9b0&quot;
      Version=&quot;2.0&quot;
      IssueInstant=&quot;2025-11-22T19:06:04.594Z&quot;&gt;
    &lt;saml:Issuer&gt;https://test-saml.com&lt;/saml:Issuer&gt;
    &lt;ds:Signature
        xmlns:ds=&quot;http://www.w3.org/2000/09/xmldsig#&quot;&gt;
      &lt;ds:SignedInfo&gt;
        &lt;ds:CanonicalizationMethod Algorithm=&quot;http://www.w3.org/2001/10/xml-exc-c14n#&quot; /&gt;
        &lt;ds:SignatureMethod Algorithm=&quot;http://www.w3.org/2001/04/xmldsig-more#rsa-sha256&quot; /&gt;
        &lt;ds:Reference URI=&quot;#_8dea871c-d9a2-4928-8219-2bad6cc9a9b0&quot;&gt;
          &lt;ds:Transforms&gt;
            &lt;ds:Transform Algorithm=&quot;http://www.w3.org/2000/09/xmldsig#enveloped-signature&quot; /&gt;
            &lt;ds:Transform Algorithm=&quot;http://www.w3.org/2001/10/xml-exc-c14n#&quot; /&gt;
          &lt;/ds:Transforms&gt;
          &lt;ds:DigestMethod Algorithm=&quot;http://www.w3.org/2001/04/xmlenc#sha256&quot; /&gt;
          &lt;ds:DigestValue&gt;q8x9brh1e7pMcTKLPMGa5RyGPgyy7EGiFD4eEwoRI0Q=&lt;/ds:DigestValue&gt;
        &lt;/ds:Reference&gt;
      &lt;/ds:SignedInfo&gt;
      &lt;ds:SignatureValue&gt;WQW3+5vmnaOXPPPD5gz1gw0I8CU1tv0jRjHhG1l2oxPmyUgRBa8dGZjderuPg70oaMcakUgLN/dOfwKE6BKMnanw42PqyZO/kIHtwepniiXMJQ+BT4Lc1MX1TLOzpqomFtoD//0jRKW0R0uvF5yOOEKMwDoh9Zkjq0WQfUlxlwrt6oTlIfNJruEtiH0pApfp2EqJ4XrKjEr39NQh2UDJfJwQOx1NMNRnyI6IjfzRYJHY/14lMjUWfe1mG3NDU1LhsUYfe4Myzg0T5ahiYmZqjCXYMEsaUJJvKlC17M23ovSa+YVP8zl0WUvMD+fpy3lewfayj6ZUl6JkuVUYQ+0MsQ==&lt;/ds:SignatureValue&gt;
      &lt;ds:KeyInfo&gt;
        &lt;ds:X509Data&gt;
          &lt;ds:X509Certificate&gt;MIIDQTCCAimgAwIBAgIUdYK4XoQpN1hFs9yHDGAU/M2cCEgwDQYJKoZIhvcNAQELBQAwSTELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAkNBMQswCQYDVQQHDAJTRjEMMAoGA1UECgwDT3JnMRIwEAYDVQQDDAlsb2NhbGhvc3QwHhcNMjUxMTIyMTY0NDQyWhcNMjYxMTIyMTY0NDQyWjBJMQswCQYDVQQGEwJVUzELMAkGA1UECAwCQ0ExCzAJBgNVBAcMAlNGMQwwCgYDVQQKDANPcmcxEjAQBgNVBAMMCWxvY2FsaG9zdDCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAKc+bRQeN+KXlE3IB5U+VJ0rU7Wv+EC9L44IbgODEWPqq6aJ0lPUwLrM7embvqFHKP/0lwbINyrwnOkVtwpmG0D43qtOACcmM6XUU9cB8j1TjEMgddVURI+TaMvWIKfV2rOzcB6x4oEOQ5cKVFMLJtTCcZwd8TKGnAbVw0jbV3cK7HW9bLtyQApZB2s41f1fyDvnOmrOShuDfLvnHaHjXD55Gjd4RpddxAMqKaL5bUIR2KPJkgb7As07ELIQmai6in0Aco5jV5HJsrJinMdIT6BOisP4DM3LjO7v5UsO8ZLqpQzg03l6fOIsiOdluAokq8N48nh/Ms2wBSs04+BKY68CAwEAAaMhMB8wHQYDVR0OBBYEFBT0hqLfFDC/87ywfCPKuw9M1xylMA0GCSqGSIb3DQEBCwUAA4IBAQA2uDbyXTqaVYrDdb0jcAmEQEMMP2YWCJhPSkgn9URqdlByG6UtVsA+ZbDUFgaQpPK9oM5yLJFeyQGhFs9hoodoqT3mhp3q/mXfEk95e7uPUV+v9HdBO1jB1PUX1j104QVmhbEGQqBMDsIPclEcXmUn3EOXSNZhQGXV/D8GRAjHvpO0bl/s9CFxvwBwupKXT5e4c61scjD17dmeVMTTfh653JGZAyR32oTFkzrZcDAO9soBUxo6dsK/mHiir5i/viVI3uS5izNHgp4aHN4awnEWm9hAMxaX16MYcXFyv4n2Prc2EM+DaNbD5Jh5GMo+VDmK8fkqaBsro+SO/o1/eFgA&lt;/ds:X509Certificate&gt;
        &lt;/ds:X509Data&gt;
      &lt;/ds:KeyInfo&gt;
    &lt;/ds:Signature&gt;
    &lt;saml:Subject&gt;
      &lt;saml:NameID Format=&quot;urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified&quot;&gt;jack.gitter@gmail.com&lt;/saml:NameID&gt;
      &lt;saml:SubjectConfirmation Method=&quot;urn:oasis:names:tc:SAML:2.0:cm:bearer&quot;&gt;
        &lt;saml:SubjectConfirmationData NotOnOrAfter=&quot;2025-11-22T19:11:04.594Z&quot;
                                      Recipient=&quot;https://sptest.iamshowcase.com/acs&quot;
                                      InResponseTo=&quot;&quot; /&gt;
      &lt;/saml:SubjectConfirmation&gt;
    &lt;/saml:Subject&gt;
    &lt;saml:Conditions NotBefore=&quot;2025-11-22T19:06:04.594Z&quot;
                     NotOnOrAfter=&quot;2025-11-22T19:11:04.594Z&quot;&gt;
      &lt;saml:AudienceRestriction&gt;
        &lt;saml:Audience&gt;IAMShowcase&lt;/saml:Audience&gt;
      &lt;/saml:AudienceRestriction&gt;
    &lt;/saml:Conditions&gt;
  &lt;/saml:Assertion&gt;
&lt;/samlp:Response&gt;
			</pre>

	Below is listed some of the most important fields, along with their purpose

                <dl class='light-gray'>
                  <dt>Response</dt>
                  <dd>The outer wrapper of the information sent from IDP to SP. It has a couple of important attributes
					  <ul>
						  <li style="margin-left: 20px">ID : <span>The id for this response. Unique for each response<span></li>
						  <li style="margin-left: 20px">Issue Instant : <span>When the response was created</span></li>
						  <li style="margin-left: 20px">Destination : <span>Where the response is being sent to, in URL format</span></li>
						  <li style="margin-left: 20px">In Response To : <span>The ID of the SAML request that corresponds to the response. 
								  In this example it is blank, as this was an IDP initiated SSO payload</span></li>
					  </ul>
				  </dd>
                  <dt>Issuer</dt>
                  <dd>The IDP's name</dd>
                  <dt>Status</dt>
                  <dd>Conveys whether the sign in was successful or not</dd>
                  <dt>Assertion</dt>
					<dd>The main element encompassing most of the user and authentication 
						information. The following are the most important inclusions that reside within the assertion</dd>
							<dt style="margin-left: 20px">Issuer</dt>
							<dd style="margin-left: 40px">The IDP's name</dd>
							<dt style="margin-left: 20px">Signature</dt>
							<dd style="margin-left: 40px">Digital signature of the assertion contents</dd>
							<dt style="margin-left: 20px">Subject</dt>
							<dd style="margin-left: 40px">Defines who the SAML assertion is about. Contains a NameID field which represents the authenticated user. There are multiple different formats for NameID, and they can be persistent or transient. The format depends the support of the SP and IDP</dd>
							<dt style="margin-left: 20px">Conditions</dt>
							<dd style="margin-left: 40px">Often defines a NotBefore and NotOnOrAfter fields, determining what time period the assertion is valid for</dd>
							<dt style="margin-left: 20px">Audience</dt>
							<dd style="margin-left: 40px">Contains the URI that identifies the intended recipient of the SAML Response</dd>
							<dt style="margin-left: 20px">Attribute Statement</dt>
							<dd style="margin-left: 40px">Contains claims about the user, typically additional information that the IDP would store such as email, name, etc</dd>
							<dt style="margin-left: 20px">AuthnStatement</dt>
							<dd style="margin-left: 40px">Describes what method the user authenticated with, such as a password. Also provides timestamp information similar to conditions</dd>
                </dl>


				To find out more, visit Microsoft's <a href='https://learn.microsoft.com/en-us/entra/identity-platform/single-sign-on-saml-protocol#response'>documentation</a>
				
			<h2>Bindings</h2>
			In order to send SAML requests and responses between SPs and IDPs, there must be agreed upon conventions and protocols. The protocol used for SAML is HTTP, and there are two main, distinct ways that these request can be sent. These are called bindings. Both the IDP and SP can define their own preferred bindings

			<h3>Post binding</h3>
			When the post binding is used, communication between IDP and SP is done through an HTTP POST request. It is most commonly supported by service providers, rather than 
			IDPs. This request is expected to be performed via HTTP form control, and has two important fields. 

                <dl class="light-gray">
                  <dt>SAMLResponse</dt>
                  <dd>
					the SAML response, base64 encoded
				  </dd>
				  <dt>RelayState</dt>
				  <dd>
					RelayState: During SP initiated SSO, the IDP must echo back what the SP sent in the SAML Request. In an IDP initiated SSO,
					the IDP can include the URL of a specific page hosted by the service provider. After the service provider parses and
					validates the SAML response, the user would be redirected to that URL. 
					This is not specifically stated in the SAML specification, but is often utilized in modern SAML flows.
				  </dd>
				</dl>
			<h3>Redirect binding</h3>
			When the redirect binding is used, communication between IDP and SP is done via HTTP GET, and the SAMLResponse and RelayState fields are send as query parameters. 
			The Redirect binding is the most commonly used format for SAML Requests. By default, the SAML is compressed via the deflate algorithm, the resulting encoded binary is 
			encoded via base64, and finally urlencoded before sending. 

			<h2>IAmShowcase website</h2>
			For the coming examples, the code implementation is acting as the IDP. In order to fulfill the other half of the SAML flow, a service provider is required. For this, <a href="https://sptest.iamshowcase.com">IAmShowcase</a> can be used, which is able to act as a mock SP and supports both IDP initiated and SP initiated SSO. 

			<h2>Metadata</h2>
			<p>
			Before jumping into the code, it's first important to understand IDP and SP metadata. These are files in written in XML which describe the specifics of what both the IDP 
			and SP expect during the SSO flow. Things such as the SP's assertion consumer service endpoint, the SP's encryption key, the IDPs login request URL, etc.
			</p>
			<h3>Downloading SP metadata</h3>
				<p>
				For most service providers, metadata should be downloadable. 
				Since IAmShowcase is a demo site specifically made to test SAML integration, the download
				is pretty straight forward

				<div class="image-description-block">
					<img src="./download-sp-meta.png" style="width:100%">
					<p>
					IAmShowcase metadata download
					</p>
				</div>

				The IAmShowcase metadata is as follows

			<pre class="prettyprint lang-xml" id="xml-block">
&lt;md:EntityDescriptor xmlns:md=&quot;urn:oasis:names:tc:SAML:2.0:metadata&quot; xmlns:ds=&quot;http://www.w3.org/2000/09/xmldsig#&quot; entityID=&quot;IAMShowcase&quot; validUntil=&quot;2025-12-09T09:13:31.006Z&quot;&gt;
	&lt;md:SPSSODescriptor AuthnRequestsSigned=&quot;false&quot; WantAssertionsSigned=&quot;true&quot; protocolSupportEnumeration=&quot;urn:oasis:names:tc:SAML:2.0:protocol&quot;&gt;
		&lt;md:NameIDFormat&gt;urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified&lt;/md:NameIDFormat&gt;
		&lt;md:NameIDFormat&gt;urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress&lt;/md:NameIDFormat&gt;
		&lt;md:AssertionConsumerService Binding=&quot;urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST&quot; Location=&quot;https://sptest.iamshowcase.com/acs&quot; index=&quot;0&quot; isDefault=&quot;true&quot;/&gt;
	&lt;/md:SPSSODescriptor&gt;
&lt;/md:EntityDescriptor&gt; </pre>
				</p>

			<h3>Creating IDP metadata</h3>
			<p>
			Because we are our own IDP in this example, we need to generate IDP metadata. 
			In order to do so, 
			first a key pair is required so that the public certificate can be embedded into the IDP metadata, and later the SAML response. The service provider will
			utilize this public key as a reference to look up internally stored keys, and verify the signature of the SAML response.
			In order to generate the pair, a simple bash script written with openSSL should suffice.

			<pre class="prettyprint lang-bsh">
#!/bin/bash

KEY=$(openssl genrsa 2048 2&gt/dev/null)
echo "$KEY"
echo "$KEY" | openssl req -new -key /dev/stdin -subj "/C=US/ST=CA/L=SF/O=Org/CN=localhost" 2&gt/dev/null | \
openssl x509 -req -days 365 -signkey <(echo "$KEY") 2>/dev/null</pre>
			</p>

			To create the IDP metadata, a website such as <a href="https://www.samltool.com/idp_metadata.php">samltool.com</a> can be used. Entering information into the required 
			fields will produce IDP metadata which looks something like the following

<pre class="prettyprint lang-xml" id="xml-block">
&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;md:EntityDescriptor xmlns:md=&quot;urn:oasis:names:tc:SAML:2.0:metadata&quot; validUntil=&quot;2025-11-24T19:31:58Z&quot; cacheDuration=&quot;PT1764444718S&quot; entityID=&quot;http://localhost:3000&quot;&gt;
  &lt;md:IDPSSODescriptor WantAuthnRequestsSigned=&quot;false&quot; protocolSupportEnumeration=&quot;urn:oasis:names:tc:SAML:2.0:protocol&quot;&gt;
    &lt;md:KeyDescriptor use=&quot;signing&quot;&gt;
      &lt;ds:KeyInfo xmlns:ds=&quot;http://www.w3.org/2000/09/xmldsig#&quot;&gt;
        &lt;ds:X509Data&gt;
          &lt;ds:X509Certificate&gt;MIIDQTCCAimgAwIBAgIUfKGITEBcwtKMKHPSumomAbLfS/kwDQYJKoZIhvcNAQELBQAwSTELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAkNBMQswCQYDVQQHDAJTRjEMMAoGA1UECgwDT3JnMRIwEAYDVQQDDAlsb2NhbGhvc3QwHhcNMjUxMTIyMTkzMTI2WhcNMjYxMTIyMTkzMTI2WjBJMQswCQYDVQQGEwJVUzELMAkGA1UECAwCQ0ExCzAJBgNVBAcMAlNGMQwwCgYDVQQKDANPcmcxEjAQBgNVBAMMCWxvY2FsaG9zdDCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAJT02NwZbGyhS8iXxtTeEiwnCaffwHL6e5M8opMRiqDsM6roFeGb96bcBVAmuTv5GpVkcBN1jN/o8nkcqfMXq678H3aT2N+LqbHsWFhU969j0j/57Im267H6Z7+eRPcEnAL8ETTT6TEUY/XFYsb41kjrH9XXL0s8pLdzR0XTFLLEXc0qHU0uFVns5JftJS7o+nQ8uOO1QrJ8Xeh10qDio00D8rqMF3DTYrLJo4UkEYoz3oa04MLWOgiNbEqsW5X11JaJnJqeQD078jruT71IO2gAOd7KkOpuZP9Swse00EXTHTx7WMYodw7l6emjU1GOJXuSbHkA1ZCEAMLjje9TFEUCAwEAAaMhMB8wHQYDVR0OBBYEFFV7jw3PtIjLQZjsu7YRXPIGmsYcMA0GCSqGSIb3DQEBCwUAA4IBAQAQZg84siAYgG4blFBmyDx+Ksy1tpemxDfGRDo3zN3mvJDsQVZU5OQIpMzp8tKoVGK+1MOEi+3sO9gnXA7moDwfqsyE2GQOurLbMhO6XJluytX0La783PJrOMf6nL6oV4vEnjqIYDa31XvYy40/XY27PRkb9HWfm3QmbxwCy1XBdu6vhAWrCON+gCWh/DUjAa21MwOwNsL1H4FAdnSS8f49E6sH15WNi2lMr8uMU9wo6vkbY5REUOE2JX/xGKrQiEHBxEuiXoiyWaS8fFuO2vJlcXjs1TxBT1ZV/dCr8TC0zKv9i4GggWijtIXEb4VcsVO9IXGF3POWo/HVex7tSQQ3&lt;/ds:X509Certificate&gt;
        &lt;/ds:X509Data&gt;
      &lt;/ds:KeyInfo&gt;
    &lt;/md:KeyDescriptor&gt;
    &lt;md:KeyDescriptor use=&quot;encryption&quot;&gt;
      &lt;ds:KeyInfo xmlns:ds=&quot;http://www.w3.org/2000/09/xmldsig#&quot;&gt;
        &lt;ds:X509Data&gt;
          &lt;ds:X509Certificate&gt;MIIDQTCCAimgAwIBAgIUfKGITEBcwtKMKHPSumomAbLfS/kwDQYJKoZIhvcNAQELBQAwSTELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAkNBMQswCQYDVQQHDAJTRjEMMAoGA1UECgwDT3JnMRIwEAYDVQQDDAlsb2NhbGhvc3QwHhcNMjUxMTIyMTkzMTI2WhcNMjYxMTIyMTkzMTI2WjBJMQswCQYDVQQGEwJVUzELMAkGA1UECAwCQ0ExCzAJBgNVBAcMAlNGMQwwCgYDVQQKDANPcmcxEjAQBgNVBAMMCWxvY2FsaG9zdDCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAJT02NwZbGyhS8iXxtTeEiwnCaffwHL6e5M8opMRiqDsM6roFeGb96bcBVAmuTv5GpVkcBN1jN/o8nkcqfMXq678H3aT2N+LqbHsWFhU969j0j/57Im267H6Z7+eRPcEnAL8ETTT6TEUY/XFYsb41kjrH9XXL0s8pLdzR0XTFLLEXc0qHU0uFVns5JftJS7o+nQ8uOO1QrJ8Xeh10qDio00D8rqMF3DTYrLJo4UkEYoz3oa04MLWOgiNbEqsW5X11JaJnJqeQD078jruT71IO2gAOd7KkOpuZP9Swse00EXTHTx7WMYodw7l6emjU1GOJXuSbHkA1ZCEAMLjje9TFEUCAwEAAaMhMB8wHQYDVR0OBBYEFFV7jw3PtIjLQZjsu7YRXPIGmsYcMA0GCSqGSIb3DQEBCwUAA4IBAQAQZg84siAYgG4blFBmyDx+Ksy1tpemxDfGRDo3zN3mvJDsQVZU5OQIpMzp8tKoVGK+1MOEi+3sO9gnXA7moDwfqsyE2GQOurLbMhO6XJluytX0La783PJrOMf6nL6oV4vEnjqIYDa31XvYy40/XY27PRkb9HWfm3QmbxwCy1XBdu6vhAWrCON+gCWh/DUjAa21MwOwNsL1H4FAdnSS8f49E6sH15WNi2lMr8uMU9wo6vkbY5REUOE2JX/xGKrQiEHBxEuiXoiyWaS8fFuO2vJlcXjs1TxBT1ZV/dCr8TC0zKv9i4GggWijtIXEb4VcsVO9IXGF3POWo/HVex7tSQQ3&lt;/ds:X509Certificate&gt;
        &lt;/ds:X509Data&gt;
      &lt;/ds:KeyInfo&gt;
    &lt;/md:KeyDescriptor&gt;
	&lt;md:SingleLogoutService Binding=&quot;urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect&quot; Location=&quot;http://localhost:3000/saml/auth/logout&quot;/&gt;
    &lt;md:NameIDFormat&gt;urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified&lt;/md:NameIDFormat&gt;
	&lt;md:SingleSignOnService Binding=&quot;urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect&quot; Location=&quot;http://localhost:3000/saml/auth&quot;/&gt;
  &lt;/md:IDPSSODescriptor&gt;
&lt;/md:EntityDescriptor&gt;
			</pre>

			Mostly all the information entered into samltool's form is embedded here. From information about the login request endpoint for SP initiated SSO, the IDP's entityID,
			the public certificate used to verify signature value on the SAML Response, and even a public key that can be used by service providers to encrypt SAML requests.

			<h3>Implementation</h3>
				<h4>Samlify</h4>
				<p>
				Samlify is a typescript library that can be used for a variety of SAML related tasks. 
				For our use case, it provides functionality to create and parse both SAML requests and responses.
				The first thing that should be done when working with samlify is downloading the IDP and SP metadata, 
				and creating the respective objects. We already took a look at these metadata files, so we can jump right into some examples. 
				To demonstrate various use cases, I've create a super basic web server that has three functionalities. 
				One is a basic IDP initiated flow with no special SAML response template. Another is an IDP initiated SSO with a custom SAML response template. 
				The final one is a service provider initiated SSO flow.
				</p>


				<h4>IDP initiated SSO example</h4>

				<p>
				The first example is the most basic: Implementing an IDP initiated SSO with no custom SAML response template. 
				The following code is used to create the SAML response itself
				</p>

<pre class='prettyprint lang-typescript'>
export const generateDefaultSAMLResponse = async (entityId: string) =&gt {
  const idp = IdentityProvider({
	metadata: readFileSync(`${__dirname}/idp/metadata.xml`),
	privateKey: readFileSync(`${__dirname}/idp/private-key.pem`)
  })

  const sp = ServiceProvider({
	metadata: readFileSync(`${__dirname}/sp/${entityId}/metadata.xml`)
  })

  const request = {
    extract: {
      request: {
	id: undefined
      }
    }
  }
 
  const { context, entityEndpoint } = await idp.createLoginResponse(sp, request, Constants.wording.binding.post, {email: 'jack.a.gitter@gmail.com'})
  return { context, entityEndpoint, relayState: 'light-blue' }
}

app.get('/sso/iamshowcase/login', async (_req: Request, res: Response) =&gt {
  const resp = await generateDefaultSAMLResponse(ENTITY_ID.I_AM_SHOWCASE)
  res.send(resp)
})
</pre>
				Two objects are created that represent the SP and the IDP which utilize the respective metadata files. Also necessary is the 
				IDP's private key used sign the SAML assertion, generated via the bash script shown earlier. The <code>idp.createLoginResponse</code> method is responsible 
				for generating the SAML response. It requires the service provider, a SAML request object, which binding to use, and a user object. Because this is 
				an IDP initiated SSO, I've created a mock SAML request object to pass in. The library will automatically extract relevant user information from the user object, and
				put it within the NameID and attributes section. Finally, returned is a <code>context</code> variable (the SAML response), 
				the <code>entityEndpoint</code> which is the ACS URL, and the <code>relayState</code>. For IAMShowcase, 
				setting the relay state changes the color of the UI of the website, nothing more.
				This method is used in a simple HTTP get request after hitting the "sso" button on the frontend



            <div class="image-description-block">
				<img src="./home.png"/>
                <p>
				Extremely polished home screen
                </p>
            </div>

			This is the code that is executed after clicking the SSO button. We parse the response from the HTTP handler in the backend, 
			and then fill our a form and post submit with the relevant details


<pre class='prettyprint lang-typescript'>
const response = await fetch('http://localhost:3000/sso/iamshowcase/login');
const data = await response.json();

const samlResponse = data.context;
const acsUrl = data.entityEndpoint;
const relayState = data.relayState

const form = document.getElementById('samlForm');
form.action = acsUrl;
document.getElementById('samlResponse').value = samlResponse;
document.getElementById('relayState').value = relayState;

form.submit();				
</pre>


				Upon reaching the service provider, we are greeted with the information held within the SAML response. Because this response only contained the bare minimum 
				information, the information shown is limited. We can see that the UI is a light blue color, as that is what we specified in our relay state

            <div class="image-description-block">
				<img src="./sp-home.png"/>
                <p>
				Service provider home screen after login via IDP
                </p>
            </div>


				<h4>IDP initated custom SAML response format example</h4>
					<p>
					Most SPs are going to require extra information about the user, 
					or other specifics surrounding the authentication that is not included by default from samilfy. 
					In these instances, samlify allows for IDPs to provide custom XML template for SAML responses. 
					This is the template used in the following example


			<pre class="prettyprint lang-xml" id="xml-block">
&lt;samlp:Response xmlns:samlp=&quot;urn:oasis:names:tc:SAML:2.0:protocol&quot; xmlns:saml=&quot;urn:oasis:names:tc:SAML:2.0:assertion&quot; ID=&quot;{ID}&quot; Version=&quot;2.0&quot; IssueInstant=&quot;{IssueInstant}&quot; Destination=&quot;{Destination}&quot; InResponseTo=&quot;&quot;&gt;
	&lt;saml:Issuer&gt;{Issuer}&lt;/saml:Issuer&gt;
  &lt;samlp:Status&gt;
    &lt;samlp:StatusCode Value=&quot;urn:oasis:names:tc:SAML:2.0:status:Success&quot;/&gt;
  &lt;/samlp:Status&gt;
  &lt;saml:Assertion xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot; ID=&quot;{AssertionID}&quot; Version=&quot;2.0&quot; IssueInstant=&quot;{IssueInstant}&quot;&gt;
	  &lt;saml:Issuer&gt;{Issuer}&lt;/saml:Issuer&gt;
    &lt;saml:Subject&gt;
		&lt;saml:NameID Format=&quot;{NameIDFormat}&quot;&gt;{NameID}&lt;/saml:NameID&gt;
      &lt;saml:SubjectConfirmation Method=&quot;urn:oasis:names:tc:SAML:2.0:cm:bearer&quot;&gt;
		  &lt;saml:SubjectConfirmationData NotOnOrAfter=&quot;2024-01-18T06:21:48Z&quot; Recipient=&quot;{Recipient}&quot; InResponseTo=&quot;&quot;/&gt;
      &lt;/saml:SubjectConfirmation&gt;
    &lt;/saml:Subject&gt;
	&lt;saml:Conditions NotBefore=&quot;{NotBefore}&quot; NotOnOrAfter=&quot;{NotOnOrAfter}&quot;&gt;
      &lt;saml:AudienceRestriction&gt;
        &lt;saml:Audience&gt;{AudienceURI}&lt;/saml:Audience&gt;
      &lt;/saml:AudienceRestriction&gt;
    &lt;/saml:Conditions&gt;
	&lt;saml:AuthnStatement AuthnInstant=&quot;{AuthnInstant}&quot; SessionNotOnOrAfter=&quot;{NotOnOrAfter}&quot; SessionIndex=&quot;{SessionIndex}&quot;&gt;
      &lt;saml:AuthnContext&gt;
        &lt;saml:AuthnContextClassRef&gt;urn:oasis:names:tc:SAML:2.0:ac:classes:Password&lt;/saml:AuthnContextClassRef&gt;
      &lt;/saml:AuthnContext&gt;
    &lt;/saml:AuthnStatement&gt;
	&lt;saml:AttributeStatement&gt;
      &lt;saml:Attribute Name=&quot;Name&quot; NameFormat=&quot;urn:oasis:names:tc:SAML:2.0:attrname-format:basic&quot;&gt;
		  &lt;saml:AttributeValue xsi:type=&quot;xs:string&quot;&gt;{Name}&lt;/saml:AttributeValue&gt;
      &lt;/saml:Attribute&gt;
      &lt;saml:Attribute Name=&quot;Email&quot; NameFormat=&quot;urn:oasis:names:tc:SAML:2.0:attrname-format:basic&quot;&gt;
		  &lt;saml:AttributeValue xsi:type=&quot;xs:string&quot;&gt;{Email}&lt;/saml:AttributeValue&gt;
      &lt;/saml:Attribute&gt;
    &lt;/saml:AttributeStatement&gt;
  &lt;/saml:Assertion&gt;
&lt;/samlp:Response&gt;
			</pre>
					Note the variables encased in {}, which are our template placeholders. These will be replaced with information from various sources, such as the IDP 
					and SP metadata, the incoming http request (in the event of SP initiated sso), or from user information the IDP has access to after login. 
					Additionally, there is the inclusion user attributes, an Authn statement, and audience restriction, most of which service providers will require. 
					The following code demonstrates how the template is used with samlify

<pre class='prettyprint lang-typescript'>
export const generateCustomSAMLResponse = async (entityId: string) =&gt {
  const template = readFileSync(`${__dirname}/idp/templates/response.xml`).toString()
  const idp = IdentityProvider({
	metadata: readFileSync(`${__dirname}/idp/metadata.xml`),
	privateKey: readFileSync(`${__dirname}/idp/private-key.pem`),
	loginResponseTemplate: {
		context: template,
		attributes: []
	}
  })

  const sp = ServiceProvider({
	metadata: readFileSync(`${__dirname}/sp/${entityId}/metadata.xml`),
	wantMessageSigned: true
  })

  const request = { extract: { request: { id: undefined } } }

  const user = {
	email: 'jack.gitter@gmail.com',
	name: 'jack',
  }

  const { context, entityEndpoint } = await idp.createLoginResponse(sp, request, Constants.wording.binding.post, user, (template: string) =&gt {
	return createTemplateCallback(idp, sp, user, template)
  })

  return { context, entityEndpoint, relayState: 'light-blue' }
}


const createTemplateCallback = (idp: any, sp: any, user: any, template: string) =&gt {
    const acsUrl = sp.entityMeta.getAssertionConsumerService(Constants.wording.binding.post)

    const nameIDFormat = idp.entitySetting.nameIDFormat
    const selectedNameIDFormat = Array.isArray(nameIDFormat) ? nameIDFormat[0] : nameIDFormat

    const id = `_${randomUUID()}`
    const now = new Date()
    const fiveMinutesLater = addMinutes(now, 5)

    const assertionId = `_${randomUUID()}`
	const sessionIndex = randomUUID()

    const tagValues = {
		ID: id,
		IssueInstant: now.toISOString(),
		Destination: acsUrl,
		Issuer: idp.entityMeta.getEntityID(),
		AssertionID: assertionId,
		NameIDFormat: selectedNameIDFormat,
		NameID: user.email,
		Recipient: acsUrl,
		NotBefore: now.toISOString(),
		NotOnOrAfter: fiveMinutesLater.toISOString(),
		AuthnInstant: now.toISOString(),
		SessionIndex: sessionIndex,
		Name: user.name,
		Email: user.email,
		AudienceURI: acsUrl
          }

    return {
        id,
        context: SamlLib.replaceTagsByValue(template, tagValues)
    }
}
					</pre>

					The code is fairly similar, and the core principals remain the same. The IDP is supplied the typical metadata information, although we now include 
					the custom template. Additionally the <code>wantMessageSigned</code> variable is set, to demonstrate more capabilities of the library. This means samlify 
					will sign both the message and the assertion automatically. Once again, a mock SAML request is utilized. One more difference in this example is 
					the inclusion of a mock user, something that could represent a database entity stored at the IDP. We supply all of the same parameters, with the addition 
					of one new one: a function which takes in our template, and should return the final SAML response. 
					We then are able to the callback function in order to replace the placeholders within the template with 
					information coming from the metadata, user object, and other sources. After logging in via the "custom sso" button in the UI, 
					more data is visible at the service provider

					

					
            <div class="image-description-block">
				<img src="./authn.png"/>
                <p>
				Authn Information that was included in the SAML Response
                </p>
            </div>
            <div class="image-description-block">
				<img src="./attributes.png"/>
                <p>
				User attributes that were included in the custom SAML Response
                </p>
            </div>
            <div class="image-description-block">
				<img src="./details.png"/>
                <p>
				Other details, not audience tag
                </p>
            </div>
				<h4>SP initiated SSO example</h4>
					Service provider initiated SSO is a bit more involved. The journey starts at the service provider. For IAMShowcase, they allow you to register IDP metadata, 
					and they generate a URL which will redirect to your IDPs single sign on service endpoint, as listed in the XML. For this instance, that is

<pre class="prettyprint lang-xml" id="xml-block">
&lt;md:SingleSignOnService Binding=&quot;urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect&quot; Location=&quot;http://localhost:3000/saml/auth&quot;/&gt;
</pre>

					The link generated by IAmShowcase is arbitrary, and only for testing purposes:


<pre class="prettyprint link">
https://sptest.iamshowcase.com/ixs?idp=2bf0fa1d7db9ecd60b2c436978513d3c1c5536a8
</pre>

					After clicking this link, IAmShowcase sends an SAML request to our local service, using the redirect binding

<pre class="prettyprint link">
http://localhost:3000/saml/auth?SAMLRequest=fZFRT4MwFIX%2FStP3ja4D3ZpBgi5Gki0uA33wrSsXIYEWe4v68y1sJvNlj809557v3G5Qdm0v0sHV%2BgifA6AjP12rUUyDmA5WCyOxQaFlByicEnm63wk%2BZ6K3xhllWnplue2QiGBdYzQlT8YqmHJjWskWgRKSbWMqI1YxtYSQlSu1Ljmv1lCyu4pxqMJwpU5yeb%2FmFXh9hjhAptFJ7WLKGY9mi8WMhwVngkUi4u%2BUbH2jRssxM6a1c70IgtYo2dYGnVgyxoIRO5CehJL0j%2B%2FRaBw6sDnYr0bB63F3dqO3Y%2B%2F80nkjO6zNt5IIc2W6QCr0FQ6Xmzw0umz0x%2B1znM4iFM9FcZgdXvLCbyBvYHHC9RKabEY8MVW1JMnSfX4J3QRXk%2BT8%2Bv%2BTyS8%3D
</pre>

					The code to handle this request is below

<pre class="prettyprint lang-typescript">
export const parseSpInitiatedLoginRequest = async (req: any, entityId: string) =&gt {
  const idp = IdentityProvider({
    metadata: readFileSync(`${__dirname}/idp/metadata.xml`),
    privateKey: readFileSync(`${__dirname}/idp/private-key.pem`),
    wantAuthnRequestsSigned: false,
  })

  const sp = ServiceProvider({
    metadata: readFileSync(`${__dirname}/sp/${entityId}/metadata.xml`),
    authnRequestsSigned: false
  })

  const {extract} = await idp.parseLoginRequest(sp, 'redirect', req)
  return {issuer: extract.issuer, id: extract.request.id}
}


const generateSignature = (...fields: string[]) =&gt {
  const payload = JSON.stringify(fields);
  const signature = crypto.createHmac('sha256', 'secret').update(payload).digest('hex');
  return signature
}

app.get('/saml/auth', async (req: Request, res: Response) =&gt {
  const {issuer, id} = await parseSpInitiatedLoginRequest(req, ENTITY_ID.I_AM_SHOWCASE)
  const signature = generateSignature(issuer, id)
  res.cookie('signature', signature, {sameSite: 'strict', httpOnly: true})
  res.cookie('issuer', issuer, {sameSite: 'strict', httpOnly: true})
  res.cookie('id', id, {sameSite: 'strict', httpOnly: true})
  res.redirect('/login')
})
					</pre>
					First, we create the IDP and SP object as usual.
					The <code>idp.parseLoginRequest</code> method can be used to parse the authentication request that the SP sent. 
					The main information from this request that is useful is the issuer, and the request ID. Utilizing those two values a signature is created, 
					and all three are set as cookies. The user is then redirected to the IDP login page. 

            <div class="image-description-block">
				<img src="./login.png"/>
                <p>
				Super advanced login page
                </p>
            </div>

            <div class="image-description-block">
				<img src="./cookies.png"/>
                <p>
				Cookies set by backend
                </p>
            </div>

			Upon filling out the username and password and hitting login, the form calls our post
			login endpoint

<pre class="prettyprint lang-typescript">
export const generateSpInitiatedSAMLResponse  = async (email: string, issuer: string, id: string) => {
  const idp = IdentityProvider({
	metadata: readFileSync(`${__dirname}/idp/metadata.xml`),
	privateKey: readFileSync(`${__dirname}/idp/private-key.pem`)
  })

  const sp = ServiceProvider({
	metadata: readFileSync(`${__dirname}/sp/${issuer}/metadata.xml`),
  })

  const request = { extract: { request: { id } } }

  const { context, entityEndpoint } = await idp.createLoginResponse(sp, request, Constants.wording.binding.post, {email})

  return { context, entityEndpoint, relayState: 'light-blue' }

}

app.post('/login', async (req: Request, res: Response) =&gt {
  const email = req.body.email
  const issuer = req.cookies.issuer
  const id = req.cookies.id
  const signature = req.cookies.signature
  const expectedSignature = generateSignature(issuer, id)
  if (signature !== expectedSignature) {
	res.status(403).send()
	return
  }
  const resp = await generateSpInitiatedSAMLResponse(email, issuer, id)
  res.send(resp)
})
</pre>


			This code is practically the same as the basic SAML response demonstration, with two major differences. Firstly, it utilizes the cookie values 
			to create a signature and check it against the cookie signature value, to ensure no end user tampering occurred with the SAML request information.
			Additionally it uses the email entered in the login form to generate the SAML response information. In a real production instance,
			user information would be taken from the database after login. After the server responds, the frontend is able to utilize the information to 
			send the SAML response to the service provider.


			<pre class="prettyprint lang-typescript">
&lt;script&gt;
  const form = document.getElementById('loginForm');
  form.addEventListener('submit', async (e) =&gt; {
    e.preventDefault(); 
    const res = await fetch('http://localhost:3000/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        email: form.email.value,
        password: form.password.value
      })
    });
    if (res.status === 403) {
      window.location.href = 'http://localhost:3000/error';
      return; 
    }
    const { context, entityEndpoint, relayState } = await res.json();
    const samlForm = document.createElement('form');
    samlForm.method = 'POST';
    samlForm.action = entityEndpoint;
    const samlInput = document.createElement('input');
    samlInput.type = 'hidden';
    samlInput.name = 'SAMLResponse';
    samlInput.value = context;
    samlForm.appendChild(samlInput);
    if (relayState) {
      const relayInput = document.createElement('input');
      relayInput.type = 'hidden';
      relayInput.name = 'RelayState';
      relayInput.value = relayState;
      samlForm.appendChild(relayInput);
    }
    document.body.appendChild(samlForm);
    samlForm.submit(); 
  });
&lt;/script&gt;
			</pre>

			After this, the user is logged into the service provider as seen in prior examples.
        </article>
    </main>
    <footer>
        <span class="date">SWE @ Sentinel Group</span>
    </footer>
</body>
</html>
