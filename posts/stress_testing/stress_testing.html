<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stress Testing with NestJS and K6</title>
    <link rel="stylesheet" href="../../styles.css">
    <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js?skin=desert"></script>
</head>
<body>
    <header>
        <h1>Stress Testing with NestJS and K6</h1>
    </header>
    <main>
        <article>
            <h1>How To Know if an Application Can Handle Production Traffic</h1>
            Many efforts are typically focused around unit, integration, and e2e tests to ensure that applications
            and APIs function as expected. These tests are extremely vital, as it ensures, for the most part, that there are no logical bugs
            within the application. One aspect that might be commonly overlooked is stress testing. With an upsege of traffic coming to an API, 
            how do developers know that their application can handle the extreme bandwidth that might come with the release of a production application?
            How can developers be sure that the application scales properly, and a system won't crash entirely? As well, some bugs, such as data races, 
            might not make themselves aparent under simple tests. Only when a high number of concurrent users are utilizing the system do these aches
            reveal themselves, with potential to cause catostrophic issues. In order to be sure of all of the aformentioned questions, stress testing
            can be implemented to be able to answer them with a high level of certainty.
            <p class="date">July 2, 2025</p>


            <h1>Basic Application Setup</h1>
            
            In order to demonstrate how to go about stress testing an application, I've developed an extremely simple NestJS application which acts as a 
            backend to a boating rental service. I've created necessary controllers, services, entities, and database conections as shown below


<pre class="prettyprint lang-typescript">@Controller('boats')
export class BoatsController {
  constructor(private boatsService: BoatsService) {}

  @Patch('rent/:id')
  public async rentBoat(@Param('id') id: UUID): Promise&ltvoid&gt {
    await this.boatsService.rentBoat(id);
  }

  @Get('available')
  public async findAvailableBoats(): Promise&ltBoat[]&gt {
    return await this.boatsService.findAvailableBoats();
  }

  @Get()
  public async findBoats(): Promise&ltBoat[]&gt {
    return await this.boatsService.findBoats();
  }

  @Patch('return/:id')
  public async returnBoat(@Param('id') id: UUID): Promise&ltvoid&gt {
    await this.boatsService.returnBoat(id);
  }

  @Patch('all/rent')
  public async rentAllBoats() {
    return await this.boatsService.rentAllBoats();
  }

  @Patch('all/return')
  public async returnAllBoats() {
    return await this.boatsService.returnAllBoats();
  }

  @Post()
  public async createBoat(@Body() body: CreateBoatDTO): Promise&ltBoat&gt {
    return await this.boatsService.createBoat(
      body.price,
      body.topSpeedInKnots,
      body.capacity,
      body.name,
    );
  }
}
</pre>




<pre class="prettyprint lang-typescript">@Injectable()
export class BoatsService {
  constructor(
    @InjectRepository(Boat) private boatsRepository: Repository&ltBoat&gt,
    private dataSource: DataSource,
  ) {}

  public async rentAllBoats(): Promise&ltBoat[]&gt {
    return await this.dataSource.transaction(async (manager) =&gt {
      const boatRepo = manager.getRepository(Boat);
      const allBoats = await boatRepo.find({
        where: {
          currentlyRented: false,
        },
      });
      const rentedBoats = allBoats.map((boat) =&gt {
        boat.rentBoat();
        return boat;
      });
      await boatRepo.save(rentedBoats);
      return allBoats;
    });
  }

  public async returnAllBoats() {
    await this.dataSource.transaction(async (manager) =&gt {
      const boatRepo = manager.getRepository(Boat);
      const allBoats = await boatRepo.find({
        where: {
          currentlyRented: true,
        },
      });
      const rentedBoats = allBoats.map((boat) =&gt {
        boat.returnBoat();
        return boat;
      });
      await boatRepo.save(rentedBoats);
    });
  }
  public async rentBoat(id: UUID): Promise&ltvoid&gt {
    await this.dataSource.transaction(async (manager) =&gt {
      const boatRepo = manager.getRepository(Boat);
      const boat = await boatRepo.findOneByOrFail({ id });
      boat.rentBoat();
      await boatRepo.save(boat);
    });
  }

  public async findAvailableBoats(): Promise&ltBoat[]&gt {
    const boats = await this.boatsRepository.find({
      where: {
        currentlyRented: false,
      },
    });
    return boats;
  }

  public async findBoats(): Promise&ltBoat[]&gt {
    return await this.boatsRepository.find();
  }

  public async returnBoat(id: UUID): Promise&ltvoid&gt {
    await this.dataSource.transaction(async (manager) => {
      const boatRepo = manager.getRepository(Boat);
      const boat = await boatRepo.findOneByOrFail({ id });
      boat.returnBoat();
      boatRepo.save(boat);
    });
  }

  public async createBoat(
    price: number,
    topSpeedInKnots: number,
    capacity: number,
    name: string,
  ): Promise&ltBoat&gt {
    const boat = new Boat(
      price,
      topSpeedInKnots,
      capacity,
      name,
      BOAT_CONDITION.NEW,
      false,
    );
    await this.boatsRepository.save(boat);
    return boat;
  }
}
</pre>
            

<pre class="prettyprint lang-typescript">@Entity('boat')
export class Boat {
  @Column({ name: 'price', type: 'int' })
  public price: number;

  @Column({ name: 'top_speed_in_knots', type: 'int' })
  public topSpeedInKnots: number;

  @Column({ name: 'capacity', type: 'int' })
  public capacity: number;

  @Column({ name: 'name', type: 'varchar' })
  public name: string;

  @Column({ name: 'condition', type: 'enum', enum: BOAT_CONDITION })
  public condition: BOAT_CONDITION;

  @Column({ name: 'currentlyRented', type: 'boolean' })
  public currentlyRented: boolean;

  @PrimaryGeneratedColumn('uuid')
  id: UUID;

  constructor(
    price: number,
    topSpeedInKnots: number,
    capacity: number,
    name: string,
    condition: BOAT_CONDITION,
    currentlyRented: boolean,
  ) {
    this.price = price;
    this.topSpeedInKnots = topSpeedInKnots;
    this.capacity = capacity;
    this.name = name;
    this.condition = condition;
    this.currentlyRented = currentlyRented;
  }

  public updateCondition(newCondition: BOAT_CONDITION) {
    this.condition = newCondition;
  }

  public rentBoat() {
    if (this.currentlyRented) {
      throw new ConflictException('Boat is currently rented already!');
    }
    this.currentlyRented = true;
  }

  public returnBoat() {
    this.currentlyRented = false;
  }
}
</pre>

            The application is not meant to be logically bulletproof. It only serves as an example which we can utilize to run stress tests against.

            <h1>Importance of environment and resource replication</h1>

            Before we get into stress testing itself, we have to discuss some important things that ensure stress testing is actually effective. The 
            most important assurance that must be made before developing stress tests it that an enviroment which closely replicates the production 
            environment is used to run the tests. This includes factors from network latency to databases all the way to processing power, RAM, and 
            other physical resources on the machine. If stress tests are ran on a machine that is more powerful than the production environment,
            false positives may be recorded. Contrarily, false negatives can be recorded if running on a much less powerful machine than production. 

            <h1>K6</h1>

            In order to write the stress tests themsevles, we will be utilizing k6, a tool which performs much of the heavy lifting for the 
            developer. Once aquanited, it is very easy to run tests, set thresholds, and analyze results. K6 is actually not built upon the NodeJS runtime, 
            but rather a propriatary runtime. As such, K6 files are self contained, and are not meant to be encoroportated into existing tests such as 
            Jest tests. In order to install, simply use a package manager of choice. I am running on mac, so I simply installed using 

<pre class="prettyprint lang-typescript">
brew install k6
</pre>

            K6 is typescript compatible. In order to install types, you can run

<pre class="prettyprint lang-typescript">
npm install --save @types/k6
</pre>



            <h1>Integration with Existing API</h1>



            <p>
            Your content goes here. This is the first paragraph of your blog post.
            </p>



            <p>
            <a href="https://github.com/Jack-Gitter/stress-testing">Link to the GitHub repository</a>
            </p>
        </article>
    </main>
    <footer>
        <span class="date">JSWE at Sentinel Group</span>
    </footer>
</body>
</html>
