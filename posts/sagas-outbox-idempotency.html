<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sagas, Outbox, and Idempotency</title>
    <link rel="stylesheet" href="../styles.css">
</head>
<body>
    <header>
        <h1>Sagas, Outbox, and Idempotency</h1>
    </header>
    <main>
        <article>
            <h1>How To Achieve Bulletproof Microservice Communication</h1>
            <p class="date">April 21, 2025</p>

            <p>
                During my short career so far, I've been exposted to a couple of different software architecture styles, but have only developed professionally 
                with one: microservices. Utilizing microserves in order to decouple a backend system into individually scalable and customizable applications is
                an extremely effective method to build sustainable infrastructure. Pair this with dockerized services, and an orchestration platform such as
                Kubernetes, and the stack is starting to feel pretty nice.
            </p>
            <p>
                With all these benefits, why would anyone ever decide to go in another direction? When utilizing microservices to build applications, 
                there are many more decisions that have to be made. How do we split the services? What protocol should be used to communicate between
                applications? And one of the most concerning of all: How is data integrity and consistency ensured? I want to focus on the last question, 
                as it's only a matter of time before as a microservice architecture using simple HTTP requests and isolated database transactions winds up in 
                an inconsistent state
            </p>

            <h2>The Setup</h2>

            <p>
                Consider an ecommerce business where you can place orders for various different items, and have them shipped to you around the world.
                This business might have services for keeping track of orders, managing inventory, and validating shipping requirements. These can be called
                the Orders, Inventory, and Shipping microservices, respectively. When a user places an order, and Order record is entered in a pending state
                in the Orders database, and a message is sent to the Inventory service to check whether there is enough inventory of the particular product.
                The inventory then reserves stock in the product, and notifies the Orders service that there is ample supply for the specific order. Then,
                the Order service must reach out to the shipping service to validate that the customer is within the allowed shipping range for the specific 
                product. Only after which, can the Order service then notify the Inventory application to remove the stock permanently, and set the order status 
                to approved. All of these steps together form a Saga, a long running, evetually consistent business process, but how is it actually implemented?
            </p>

            <h2>Queues</h2>

            <p>
                There are many different ways that different computers can communicate with one another. One of the most popular is the HTTP protocol, 
                built ontop of TCP. With HTTP, if a request fails due to a networking outage or other unexpected issue, there is little that can be done.
                Exponential backoff can be used to build in some improvements, although it pails in comparison when put up against a message broker. A message broker
                typically utilizes message queues in order to route requests between services. Queues, such as RabbitMQ utilize other protocols such as AMQP to send 
                and recieve data. Some of the biggest improvements seen when switching over to using message queues for communication is decoupling of applications
                and optional durability. A message queue can be thought of like a buffer, it holds messages until the recieving application is ready, and it can 
                re-queue messages in the event of failures. For example, with HTTP if a request from service A is sent to service B which has crashed, then the 
                service will simply not get the message. This indicates tight coupling between the two services. If service A uploads the message to a queue however,
                then the queue will hold the message until service B comes back online, and is ready to process the message. In the meantime, service A can go about 
                whatever it needs to do until service B sends a response if necessary. 

                To apply this to our specific scenario, we would first recieve an HTTP request to our Orders service to kick off our Saga. The Orders service would
                write a pending order to the database, send a message to the queue which should be eventually delivered to the Inventory service, and can process
                other messages in the meantime. Once the Inventory service has responded, then the Orders service can upload a message to the queue directed at the 
                Shipping service, and so on. As a side note, the messages can be very "thin", in the sense that they do not need to contain a lot of data. One
                of the huge benefits of microserices is that the Orders service should know a lot about order details, but the inventory service might only need
                to know the productId associated with the order. This results in a nice separation of concerns, leading to messages which only need to hold 
                foreign references to "Entities" owned by other services. See DDD Blog to learn more.

                With the implementation of queues inbetween our services, we have greatly improved our resiliance! However, consider the following scenario. The 
                Order service recieves a message to place a pending order. It writes the pending order to the database, then crashes before it can send the message. 
                The order service will come back online, and have a pending order in the database, but no message sent out to kick off our Saga. The end user will
                be left at some sort of waiting or error screen, and even worse our data is corrupted.
            </p>

            <h2>Outbox Pattern</h2>

            <p>
                An outbox is like a holding station for any outgoing messages that a service should send at some point, in order to be eventually consistent.
                This is best implemented as a database table, so that transactional consistency can be achieved between processing a request, and writing 
                a message to another service. Lets take the orders service example once more. An HTTP request comes in to place a pending order. The 
                Order service starts a transaction, writes this pending order to the database, and then writes a message to the InventoryReservationOutbox table. 
                The service then commits the transaction, so that both the message and the pending order are either both written, or neither are. On startup, 
                the Order service is set up to poll the InventoryReservationOutbox table for outgoing messages every X seconds. Once this polling functionality is 
                triggered, the message is pulled from the table, converted into JSON, and sent into the message queue for the Inventory service to process at a 
                later point. Once the message is in the queue, it is safe to be deleted from the InventoryReservationOutbox table. Most queues have configurable 
                durability, meaning if they crash with messages inside them they are able to enqueue them after coming back up again. 

                All done, right?! Wrong. Most message queues also have something called "at least once" delivery, meaning that messages might be sent to consumers
                such as the Inventory service more than once. If we send the same exact product reservation message to the Inventory service more than once, 
                we want the Inventory service to ignore any occurances of the message past the first 
            </p>
            

            <h2>Inbox Pattern</h2>
            <p>
                The inbox pattern, better known as the idempotent consumer pattern utilizes a similar approach to automic message processing as the outbox pattern,
                although in reverse. The inbox pattern writes incomming messages into a database table within a transaction which handles associated work to said
                message. If the work for the message succeeds, then the message is written to the inbox. Subsequent messages are ignored. 
                If the work fails, then we can reprocess the message at a later point. In our example, the Order service attaches the specific, auto incrementing 
                primary key for each specific order to the message it sends to the Inventory Service. This way, the inventory service is able to identify 
                duplicated messages, different from two messages with the same contents and different orderIds. It recieves the message, begins a transaction, 
                reserves inventory, writes the incomming message to the outbox, and a response message to the InventoryReservation outbox table, to later be sent
                to the Order service to continue on with the Saga
            </p>

            <h2>Compensating Actions</h2>
            <p>
                * what are compensating actions
                * why you cannot send all steps to sagas in parallel, compensating actions might be processed before the actual step!
            </p>

            <h2>The implementation</h2>

            <p>
                Now that we are all together on a theoretical level, lets talk implementation. I'll be using NodeJS, and NestJS, a framework for backend 
                services. My first thought was to implement a representation of a saga via an in-memory class. It would implement a ISagaOrchestrator  
                and have a list of steps, which implemented an ISagaStep interface. Below are the example classes

                CODE

                This felt very organized and enterprised. Once a message came in, I would write the order and the InventoryReserve message to the database. Then, 
                every 5 seconds I would poll the outbox for new messages. If any were found, I would create a Saga with the needed steps, add it to the activeSagas
                array in the service class, and simply call the begin() method to kick off the first message and then delete the message from the outbox. The saga
                had code registered to listen on the corresponding queue for incomming response messages, and the world was great. Until I realized that I had 
                one of the most annoying kind of bugs, a data race. Lets say for example we have two incomming order requests, which kicks off two sagas: Saga1 and 
                Saga2. Saga1 and Saga2 both send out messages to the InventoryReserve channel, and listen on the corresponding InventoryReserveResponse queue for 
                updates. This is actually whats known as the competing consumer pattern, and can be great in some cases! A response will come to the queue, and either
                Saga1 or Saga2 can get the message, but only one of them. In some cases, this allows for essentially a multithreading sort of functionality. But in 
                our scenario, it allows for Sagas to recieve the responses meant for other Sagas, meaning if Saga1's inventory request was denied but Saga2's wans't,
                Saga1 could recieve an successful message while Saga2 recieved the rejected message -- not good. So how do we remedy this? Back to the drawing board.
                We need one sort of "global" listener per response queue, and we need to be able to route it to the specific Saga it belongs to. I decided to 
                create a map, from orderId to saga and attach the orderId to the message. When a message comes back, we will simplyl look up the saga in the map,
                and call nextstep. Now another problem, remember "at least once delivery?" well we have two options here. One is to use the inbox pattern to ignore
                incomming requests. Something I just thought of now, but nevertheless I went in another direction. Instead of making the method called invokeNext(),
                just make the method take in a specific step, and invoke that step. That way, we can invoke steps multiple times, and idempotent consumers 
                will ignroe duplicated messages. Looking back on it now, its stupid. I should have just used the inbox pattern here as well. 
                Finally, 
            </p>



            <h2>The Fruits of April 18-20</h2>

            <p>
            Below is a link to a Github repository with the code implementation for the described example scenario. It utilizes NestJS, and dockerized
            Postgres and RabbitMQ instances. I was too lazy to configure a .env, so please clear off ports 3000, 3001, 3002, 1000, 1001, and 5672 
            <a href="https://github.com/Jack-Gitter/saga-outbox">Repo Link</a>
            </p>
            
            todos: 
            * saga in memory representation. Two sagas waiting at the same point in time on the same channel, might receieve message meant for the other saga!
            * figured out that a router on each individual queue is more effective
            
            
        </article>
    </main>
    <footer>
        <span class="date">JSWE at Sentinel Group</span>
    </footer>
</body>
</html>
