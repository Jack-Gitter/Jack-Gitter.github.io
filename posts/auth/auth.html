<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IDPs, Stytch, Oauth, OIDC, SAML, SSO</title>
    <link rel="stylesheet" href="../../styles.css">
    <link rel="stylesheet" href="./auth.css">
    <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js?skin=desert"></script>
</head>
<body>
    <header>
        <h1>IDPs, Stytch, Oauth, OIDC, SAML, SSO</h1>
    </header>
    <main>
        <article>
            <h1>All About Auth</h1>
            <p class="date">September 24, 2025</p>

            <p>
            Authentication and authorization are two critical parts of any software which has the notion of a "user". Authentication allows a user or system to prove 
            that they are who they say they are, and authorization gives an entity access to protected resources. 
            The combination of these two principals allows for complex and robust user management, and a plethora of protocols, frameworks, and jargon to go along with it. I have 
            created a small application which demonstrates multiple auth flows, and will be referencing it throughout the article.
            </p>
            
            <h2>OAuth</h2>

                OAuth is an authorization framework built to grant access to resources from one application to another. It is not concerned with who 
                is making a request for information, but only if that request is allowed or not. Here are some important terms that oauth
                defines

                <dl>
                  <dt>Client</dt>
                  <dd>The server requesting protected resources.</dd>

                  <dt>Resource Server</dt>
                  <dd>The server which contains protected resources.</dd>

                  <dt>Authorization Server</dt>
                  <dd>The server which issues access tokens, refresh tokens, etc.</dd>

                  <dt>Access Token</dt>
                  <dd>A string which is sent with requests to a resource server. The resource server uses the access token to determine whether or not the request is valid.</dd>

                  <dt>Refresh Token</dt>
                  <dd>A string which is used to obtain a new access token when the current one expires.</dd>

                  <dt>Opaque Tokens</dt>
                  <dd>Access tokens which are not decipherable by the client application. They only "mean" something to the server.</dd>

                  <dt>JWT</dt>
                  <dd>A token format which is decipherable by the client application. The client application is able to view what access is defined for the provided token. A JWT is also signed, and not encrypted in any way. The signature helps the server know that the token has not been tampered with in or before transit.</dd>

                  <dt>Claims</dt>
                  <dd>A description of what resources the access token gives the client access to.</dd>
                </dl>

                <br>

                In general, the OAuth flow is initiated when an application needs access to a users resources. The client application redirects the user to the authorization server's sign-in page, where the user enters their credentials. During the sign-in process, the user is asked to accept a list of claims that the client application is requesting. After the user successfully logs in and accepts these claims, they are redirected back to the client application. 

            <h2>Local vs Provided Access Tokens</h2>
                A provided access token is an access token which is provided to an application from a third party authorization server, think google, okta, etc. A local access token is one issued by a server that in-house developers control. Provided access tokens are useful for reaching out to third party resource servers to fetch user data, while local access tokens can be used to protect a backend HTTP server which serves content from a database that you own.

                <h3>Provided Access Token Example</h3>
                The following is a concrete example of an OAuth flow implemented with a simple local express server and Google's auth server.
                First, the action is kicked off when the user clicks on the "Get Access Token" button. It sends a request to an endpoint hosted via express, 
                which executes the following code. 

                <img class="google-token-button" src="./images/GoogleAccessToken/GoogleAccessTokenButton.png">

<pre class='prettyprint lang-typescript'>
export function redirect_to_google_acess_token_auth(req:Request, res:Response) {
    const oauth2Client = new google.auth.OAuth2({
        clientId: process.env.CLIENT_ID ?? '',
        clientSecret: process.env.CLIENT_SECRET ?? '',
        redirectUri: 'http://localhost:3000/login/access/google'
    }
    );
    const scopes = [
      'https://www.googleapis.com/auth/blogger',
      'https://www.googleapis.com/auth/calendar',
      'https://www.googleapis.com/auth/userinfo.email',
      'https://www.googleapis.com/auth/userinfo.profile'
    ];
    const url = oauth2Client.generateAuthUrl({
      access_type: 'offline',
      scope: scopes
    });
    res.redirect(url)
}</pre>

This does a couple of things. Firstly, it initializes the google oauth client library for nodejs, which we provide a clientId and secret to. These values are generated when you create a project with google, and can be found in the dashboard. We also a redirectUri. This is how google knows to reidrect to our backend to finish the authorization process. We also define the claims that our application is requesting access to. These will be asked to be accepted during the auth process for the user. Finally, we use the google auth library to generate the url to the auth server login form, and redirect the user there. Once the user is redirected, they are asked to sign in with google normally. (screenshot here). After this, they are asked to accept the claism that we have defined, to give access to our application to those resources (screenshot here). After the user completes the auth process, our backend is hit and accepts an authorization code as a query parameter. Here is the code that handles the request from google

<pre class='prettyprint lang-typescript'>
export async function auth_access_token(req: Request, res: Response) {
    const code = req.query.code as string

    const oauth2Client = new google.auth.OAuth2({
            clientId: process.env.CLIENT_ID ?? '',
            clientSecret: process.env.CLIENT_SECRET ?? '',
            redirectUri: 'http://localhost:3000/login/access/google'
        }
    );
    try {
        const { tokens } = await oauth2Client.getToken(code)
        const accessToken = tokens.access_token
        const refreshToken = tokens.refresh_token
        const expiresIn = tokens.expiry_date ?? Date.now() + 60 * 60
        res.cookie('access_token', token)
        res.cookie('refresh_token', token)
        res.redirect('http://localhost:3001')
    } catch (e) {
        if (e instanceof Error) {
            res.status(400).send(e.message)
        } else {
            res.status(500).send('Something went wrong')
        }
    }
}
</pre>

You can see that we are processing the code from the query parameters, and initializing another version of the google oauth client. We are required to exchange this authorization code for an access token, which is also handled through another call of the client library. This Oauth flow is called the "authorization code flow", meaning that google does not directly provide us with an access token. Rather, we have to request one after recieveing the authorziation code. Finally, after getting both access and refresh tokens in exchange for our authorization code, The user is redirected to our frontend, and the backend sets the access token as a cookie. 


This code is a slight oversimplification of what is actually in the repository. In order to understand that, we must take a look at local access tokens.
                <h3>Show wrapping of google access token</h3>
                    why local access tokens
                    implementation
                    here, show second half of google example where we use it as an Idp kind of
            <h2>Idps</h2>
                <h3>what are they, why are they useful</h3>
                <h3>different ways to integrate</h3>
                    headless frontend
                    frontend
                    backend 
                <h3>Sytch code example with code</h3>
            <h2>Authentication</h2>
                used to prove a user is who they say they are
                <h3>Authencation vs authorization</h3>
                used for SSO. The main difference is that an access token is typically used by an app to request resources. authentication is mainly for users, so that
                they can be signed in to third party apps and interact with them from the browser
            <h2>OIDC</h2>
                <h3>what is it</h3>
                    extension of oauth
                    used for authentication
                    id token returned
                    not meant to be sent to an auth server
                    proves that a user is who they say they are
                    useful for SSO, Idps can talk directly to auth servers to verify ID tokens to authenticate users
                <h3>Google OIDC login code example with code</h3>
                    can sometimes be sent to local server to generate JWT 
                <h3>SAML</h3>
                same as oauth, more mature protocl but same principals. 
                <h3>IDP initiated SSO vs SP initiated SSO</h3>
                <h3>Grafana and keycloak example with code</h3>
            <a href="https://github.com/yourusername/repository">Link to the GitHub repository</a>
        </article>
    </main>
    <footer>
        <span class="date">JSWE at Sentinel Group</span>
    </footer>
</body>
</html>
