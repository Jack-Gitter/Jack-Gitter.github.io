<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IDPs, Stytch, Oauth, OIDC, SAML, SSO</title>
    <link rel="stylesheet" href="../../styles.css">
    <link rel="stylesheet" href="./auth.css">
    <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js?skin=desert"></script>
</head>
<body>
    <header>
        <h1>IDPs, Stytch, Oauth, OIDC, SAML, SSO</h1>
    </header>
    <main>
        <article>
            <h1>All About Auth</h1>
            <p class="date">September 24, 2025</p>

            <p>
            Authentication and authorization are two critical parts of any software which has the notion of a "user". Authentication allows a user or system to prove 
            that they are who they say they are, and authorization gives an entity access to protected resources. 
            The combination of these two principals allows for complex and robust user management, and a plethora of protocols, frameworks, and jargon to go along with it. I have 
            created a small application which demonstrates multiple auth flows, and will be referencing it throughout the article.
            </p>
            
            <h2>OAuth</h2>

                OAuth is an authorization framework built to grant access to resources from one application to another. It is not concerned with who 
                is making a request for information, but only if that request is allowed or not. Here are some important terms that oauth
                defines

                <dl>
                  <dt>Client</dt>
                  <dd>The server requesting protected resources.</dd>

                  <dt>Resource Server</dt>
                  <dd>The server which contains protected resources.</dd>

                  <dt>Authorization Server</dt>
                  <dd>The server which issues access tokens, refresh tokens, etc.</dd>

                  <dt>Access Token</dt>
                  <dd>A string which is sent with requests to a resource server. The resource server uses the access token to determine whether or not the request is valid.</dd>

                  <dt>Refresh Token</dt>
                  <dd>A string which is used to obtain a new access token when the current one expires.</dd>

                  <dt>Opaque Tokens</dt>
                  <dd>Access tokens which are not decipherable by the client application. They only "mean" something to the server.</dd>

                  <dt>JWT</dt>
                  <dd>A token format which is decipherable by the client application. The client application is able to view what access is defined for the provided token. A JWT is also signed, and not encrypted in any way. The signature helps the server know that the token has not been tampered with in or before transit.</dd>

                  <dt>Scopes</dt>
                  <dd>A description of what resources the access token gives the client access to.</dd>
                </dl>

                <br>

                In general, the OAuth flow is initiated when an application needs access to a users resources. The client application redirects the user to the authorization server's sign-in page, where the user enters their credentials. During the sign-in process, the user is asked to accept a list of scopes that the client application is requesting. After the user successfully logs in and accepts these scopes, they are redirected back to the client application. 

            <h2>Local vs Provided Access Tokens</h2>
                A provided access token is an access token which is provided to an application from a third party authorization server, think google, okta, etc. A local access token is one issued by a server that in-house developers control. Provided access tokens are useful for reaching out to third party resource servers to fetch user data, while local access tokens can be used to protect a backend HTTP server which serves content from a database that you own.

                <h3>Provided Access Tokens</h3>
                The following is a concrete example of an OAuth flow implemented with a simple local express server and Google's auth server.
                First, the action is kicked off when the user clicks on the "Get Access Token" button. It sends a request to an endpoint hosted via express, 
                which executes the following code. 

                <img class="auth-images" src="./images/GoogleAccessToken/GoogleAccessTokenButton.png">

<pre class='prettyprint lang-typescript'>
export function redirect_to_google_acess_token_auth(req:Request, res:Response) {
    const oauth2Client = new google.auth.OAuth2({
        clientId: process.env.CLIENT_ID ?? '',
        clientSecret: process.env.CLIENT_SECRET ?? '',
        redirectUri: 'http://localhost:3000/login/access/google'
    }
    );
    const scopes = [
      'https://www.googleapis.com/auth/blogger',
      'https://www.googleapis.com/auth/calendar',
      'https://www.googleapis.com/auth/userinfo.email',
      'https://www.googleapis.com/auth/userinfo.profile'
    ];
    const url = oauth2Client.generateAuthUrl({
      access_type: 'offline',
      scope: scopes
    });
    res.redirect(url)
}</pre>

Firstly, the code initializes the google OAuth2 client library for nodejs. We provide the client a clientID and secret, which can be found in the google dashboard after creating a project there. Additionally supplied to the OAuth2 client is a redirect URI. This is where Google will reidrect to after the end user finishes the authorization process. Also defined are scopes that our application is requesting access to. During the auth process, a popup will appear and ask the user to confirm the application can have access to said resources. Finally, the OAuth2 library is used to generate the url to the auth server login form, and express redirects the browser there. Once the user is redirected, they are greeted with a normal google login screen. 

<img class="auth-images" src="./images/GoogleAccessToken/GoogleAccessTokenSignIn.png">

After entering their credentials, they are asked to accept the scopes

<img class="auth-images" src="./images/GoogleAccessToken/GoogleAccessTokenGeneralClaims.png">

Clicking on the "5 Services" button reveals the scopes that we defined earlier in the code when generating the redirect url
<img class="auth-images" src="./images/GoogleAccessToken/GoogleAccessTokenClaims.png">

After the user accepts the scopes, google redirects to the provided redirect URI, which hosts an HTTP endpoing via express. Google will send us an authorization code, which our backend will have to parse from the query parameters and exchange for an access token. 

<pre class='prettyprint lang-typescript'>
export async function auth_access_token(req: Request, res: Response) {
    const code = req.query.code as string

    const oauth2Client = new google.auth.OAuth2({
            clientId: process.env.CLIENT_ID ?? '',
            clientSecret: process.env.CLIENT_SECRET ?? '',
            redirectUri: 'http://localhost:3000/login/access/google'
        }
    );
    try {
        const { tokens } = await oauth2Client.getToken(code)
        const accessToken = tokens.access_token
        const refreshToken = tokens.refresh_token
        const expiresIn = tokens.expiry_date ?? Date.now() + 60 * 60
        res.cookie('access_token', token)
        res.cookie('refresh_token', token)
        res.redirect('http://localhost:3001')
    } catch (e) {
        if (e instanceof Error) {
            res.status(400).send(e.message)
        } else {
            res.status(500).send('Something went wrong')
        }
    }
}
</pre>

After we recieve our access (and refresh) token(s), we then can set them as cookies for the frontend to store, and redirect the user back to our application. It can be seen that the user status in the top left has now changed to indicate they are logged in. The check simply verifies the existance of the access token and refresh tokens in the cookies. 

<img class="auth-images" src="./images/GoogleAccessToken/GoogleAccessTokenLoggedIn.png">

This flow demonstrated is known as the "Authorization Code Flow", and is the most common amongst web applications. In reality, this code is a slight modification of what is actually in the repository, as it follows a local access token pattern. 

                <h3>Local Access Tokens</h3>
                    Often times, the resource server which the frontend application will be requesting data from is actually in-house. 
                    Additionally, it is extremely common for applications to have a local notion of a user, with specific roles and permissions which do not make sense 
                    outside of that application's context. The implementation of this often manifests in the form of permissions and roles stored in a database, associated with 
                    some sort of user object. When this is the case, this information is required to figure out if the client requesting data from the resource server is allowed 
                    to access it. During the auth flow, this information must be encapsulated in the access token and be readable by the in-house resource server. The token that 
                    is a result of the encapsulation of all of this data is known as a local access token. Generally speaking, after an access token is retrieved from 
                    a third party such as google, data about the sepcific user is looked up in an internal database. That data, along with any other data fetched via the access 
                    token and third-party apis, is wrapped up in a JWT and signed with an internal private key, and returned to the frontend. 
                    On requests to an internal resource server, this JWT is provided and verified with our own private key. The JWT acts as the local access token in this example, 

                <div class='sidenote'>
                    It is still useful to have users log in via a third party auth server initially such as google,
                    to keep password management, verification, and other complexities to a proven system
                </div>

                    show the code for the second half of the auth flow, 
                    show the typeorm entity
                    show postgres database schema
                    show the user that I have in the db with admin permissions
                    show settign the cookie, 
                    show the actual JWT 

            <h2>Idps</h2>
                <h3>what are they, why are they useful</h3>
                <h3>different ways to integrate</h3>
                    headless frontend
                    frontend
                    backend 
                <h3>Sytch code example with code</h3>
            <h2>Authentication</h2>
                used to prove a user is who they say they are
                <h3>Authencation vs authorization</h3>
                used for SSO. The main difference is that an access token is typically used by an app to request resources. authentication is mainly for users, so that
                they can be signed in to third party apps and interact with them from the browser
            <h2>OIDC</h2>
                <h3>what is it</h3>
                    extension of oauth
                    used for authentication
                    id token returned
                    not meant to be sent to an auth server
                    proves that a user is who they say they are
                    useful for SSO, Idps can talk directly to auth servers to verify ID tokens to authenticate users
                <h3>Google OIDC login code example with code</h3>
                    can sometimes be sent to local server to generate JWT 
                <h3>SAML</h3>
                same as oauth, more mature protocl but same principals. 
                <h3>IDP initiated SSO vs SP initiated SSO</h3>
                <h3>Grafana and keycloak example with code</h3>
            <a href="https://github.com/yourusername/repository">Link to the GitHub repository</a>
        </article>
    </main>
    <footer>
        <span class="date">JSWE at Sentinel Group</span>
    </footer>
</body>
</html>
