skinny messages
microservices only know about what they need to know, carry foreign keys to address other microservices
aggregate roots, consistency boundary business invariants
the rest can be eventual consistency, eventual does not mean forever just not going to go to jail if it messes up 
business logic belongs in the code!
domain layer is where bsuiness logic goes and entities, has no dependencies on anything else. Makes it sooooo easy to test!
services wrap around entities
repositories fetch entities from database, services call entity methods to perform busines logic, then call repository to save htem back
domain events communicate between aggregate roots, so that they are decoupled. EVENTUALLY YOU CAN SEPARATE these things into separate microservices!
even swap out databases, so you make an interface and define it in the service layer, but that actual implementation goes in infra layer. the circle diagram of dependencies is good!


